Index: app/src/main/java/de/monokel/frontend/MainActivity.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package de.monokel.frontend;\r\n\r\nimport androidx.appcompat.app.AppCompatActivity;\r\n\r\nimport android.app.NotificationChannel;\r\nimport android.app.NotificationManager;\r\nimport android.app.PendingIntent;\r\nimport android.content.Context;\r\nimport android.Manifest;\r\nimport android.annotation.TargetApi;\r\nimport android.app.AlarmManager;\r\nimport android.app.AlertDialog;\r\nimport android.content.BroadcastReceiver;\r\nimport android.content.DialogInterface;\r\nimport android.content.Intent;\r\nimport android.content.IntentFilter;\r\nimport android.content.SharedPreferences;\r\nimport android.os.Build;\r\nimport android.content.pm.PackageManager;\r\nimport android.os.Bundle;\r\nimport android.util.Log;\r\nimport android.view.View;\r\nimport android.widget.Button;\r\nimport android.widget.ImageButton;\r\nimport android.widget.ImageView;\r\nimport android.widget.TextView;\r\n\r\nimport org.altbeacon.beacon.BeaconManager;\r\n\r\nimport java.util.Calendar;\r\nimport java.util.HashMap;\r\nimport java.util.Objects;\r\n\r\nimport de.monokel.frontend.exceptions.KeyNotRequestedException;\r\nimport de.monokel.frontend.provider.Alarm;\r\nimport de.monokel.frontend.provider.Key;\r\nimport de.monokel.frontend.provider.LocalSafer;\r\nimport de.monokel.frontend.provider.NotificationService;\r\nimport de.monokel.frontend.provider.RequestedObject;\r\nimport de.monokel.frontend.provider.RetrofitService;\r\nimport de.monokel.frontend.utils.RetryCallUtil;\r\nimport retrofit2.Call;\r\nimport retrofit2.Callback;\r\nimport retrofit2.Response;\r\nimport retrofit2.Retrofit;\r\nimport retrofit2.converter.gson.GsonConverterFactory;\r\n\r\n/**\r\n * Main screen for CoWApp\r\n *\r\n * @author Tabea leibl\r\n * @author Philipp Alessandrini, Mergim Miftari, Nico Martin\r\n * @version 2020-11-03\r\n */\r\npublic class MainActivity extends AppCompatActivity {\r\n\r\n    //TAG for Logging example: Log.d(TAG, \"fine location permission granted\"); -> d for debug\r\n    protected static final String TAG = \"MainActivity\";\r\n\r\n    //For push notification\r\n    public static final String CHANNEL_ID = \"pushNotifications\";\r\n    private NotificationManager notificationManager;\r\n\r\n    // for client-server-communication\r\n    private Retrofit retrofit;\r\n    private RetrofitService retrofitService;\r\n    private String BASE_URL = \"http://10.0.2.2:3000\"; // for emulated phone\r\n\r\n    //Expected Permission Values\r\n    private static final int PERMISSION_REQUEST_FINE_LOCATION = 1;\r\n    private static final int PERMISSION_REQUEST_BACKGROUND_LOCATION = 2;\r\n\r\n    //For the once-a-day-alarm-clock for deleting keys that are older than 3 weeks\r\n    private PendingIntent myPendingIntent;\r\n    private AlarmManager alarmManager;\r\n    private BroadcastReceiver myBroadcastReceiver;\r\n    private Calendar firingCal;\r\n\r\n    //To display the current risk status\r\n    private static ImageView trafficLight;\r\n    private static TextView riskStatus;\r\n\r\n\r\n    String prefDataProtection = \"ausstehend\";\r\n\r\n    @Override\r\n    protected void onCreate(Bundle savedInstanceState) {\r\n        super.onCreate(savedInstanceState);\r\n        setContentView(R.layout.activity_main);\r\n\r\n        //traffic light image view and risk status text view\r\n        this.trafficLight = (ImageView) this.findViewById(R.id.trafficLightView);\r\n        this.riskStatus = (TextView) this.findViewById(R.id.RiskView);\r\n\r\n        //Check bluetooth and location turned on\r\n        verifyBluetooth();\r\n        //Request needed permissions\r\n        requestPermissions();\r\n\r\n        // init retrofit\r\n        retrofit = new Retrofit.Builder()\r\n                .baseUrl(BASE_URL)\r\n                .addConverterFactory(GsonConverterFactory.create())\r\n                .build();\r\n        retrofitService = retrofit.create(RetrofitService.class);\r\n\r\n        //Create channel for push up notifications\r\n        createNotificationChannel();\r\n\r\n        //show current risk level (updated once a day)\r\n        showTrafficLightStatus();\r\n        showRiskStatus();\r\n\r\n        //If the app is opened for the first time the user has to accept the data protection regulations\r\n        if (firstAppStart()) {\r\n            Intent nextActivity = new Intent(MainActivity.this, DataProtectionActivity.class);\r\n            startActivity(nextActivity);\r\n        } else {\r\n            //Info button listener\r\n            Button infoButton = (Button) findViewById(R.id.InfoButton);\r\n\r\n            infoButton.setOnClickListener(new View.OnClickListener() {\r\n                @Override\r\n                public void onClick(View v) {\r\n                    //Go to info screen\r\n                    Intent nextActivity = new Intent(MainActivity.this, InfoActivity.class);\r\n                    startActivity(nextActivity);\r\n                }\r\n            });\r\n\r\n            //Settings button listener\r\n            ImageButton settingsButton = (ImageButton) findViewById(R.id.EinstellungenButton);\r\n\r\n            settingsButton.setOnClickListener(new View.OnClickListener() {\r\n                @Override\r\n                public void onClick(View v) {\r\n                    //Go to settings screen\r\n                    Intent nextActivity = new Intent(MainActivity.this, SettingsActivity.class);\r\n                    startActivity(nextActivity);\r\n                }\r\n            });\r\n\r\n            //LOG button listener\r\n            Button logButton = (Button) findViewById(R.id.LOGButton);\r\n\r\n            logButton.setOnClickListener(new View.OnClickListener() {\r\n                @Override\r\n                public void onClick(View v) {\r\n                    //Go to LOG screen\r\n                    Intent nextActivity = new Intent(MainActivity.this, LogActivity.class);\r\n                    startActivity(nextActivity);\r\n                }\r\n            });\r\n\r\n            //Test menu button listener\r\n            Button testMenuButton = (Button) findViewById(R.id.TestMenuButton);\r\n\r\n            testMenuButton.setOnClickListener(new View.OnClickListener() {\r\n                @Override\r\n                public void onClick(View v) {\r\n                    //Go to test menu screen\r\n                    Intent nextActivity = new Intent(MainActivity.this, TestMenuActivity.class);\r\n                    startActivity(nextActivity);\r\n                }\r\n            });\r\n\r\n            //Report infection button listener\r\n            Button reportInfectionButton = (Button) findViewById(R.id.InfektionMeldenButton);\r\n\r\n            reportInfectionButton.setOnClickListener(new View.OnClickListener() {\r\n                @Override\r\n                public void onClick(View v) {\r\n                    //Go to screen to report infection\r\n                    Intent nextActivity = new Intent(MainActivity.this, ReportInfectionActivity.class);\r\n                    startActivity(nextActivity);\r\n                }\r\n            });\r\n\r\n            //suspicion button listener\r\n            Button suspicionButton = (Button) findViewById(R.id.VerdachtButton);\r\n\r\n            suspicionButton.setOnClickListener(new View.OnClickListener() {\r\n                @Override\r\n                public void onClick(View v) {\r\n                    //Go to screen to inform what to do with infection suspicion\r\n                    Intent nextActivity = new Intent(MainActivity.this, SuspicionActivity.class);\r\n                    startActivity(nextActivity);\r\n                }\r\n            });\r\n        }\r\n\r\n        //Register AlarmManager Broadcast receive. (For the once-a-day-alarm-clock for deleting keys older then 3 weeks.\r\n        firingCal= Calendar.getInstance();\r\n        firingCal.set(Calendar.HOUR, 8); // alarm hour\r\n        firingCal.set(Calendar.MINUTE, 0); // alarm minute\r\n        firingCal.set(Calendar.SECOND, 0); // and alarm second\r\n        long intendedTime = firingCal.getTimeInMillis();\r\n\r\n        registerMyAlarmBroadcast();\r\n        alarmManager.setRepeating( AlarmManager.RTC_WAKEUP, intendedTime , AlarmManager.INTERVAL_DAY , myPendingIntent );\r\n    }\r\n\r\n    /**\r\n     * This method supports the once-a-day-alarm-clock for deleting keys older then 3 weeks.\r\n     */\r\n    private void registerMyAlarmBroadcast()\r\n    {\r\n        //This is the call back function(BroadcastReceiver) which will be call when your\r\n        //alarm time will reached.\r\n        myBroadcastReceiver = new BroadcastReceiver() {\r\n            @Override\r\n            public void onReceive(Context context, Intent intent) {\r\n                Alarm.dailyBusiness();\r\n            }\r\n        };\r\n\r\n        registerReceiver(myBroadcastReceiver, new IntentFilter(\"com.alarm.example\") );\r\n        myPendingIntent = PendingIntent.getBroadcast( this, 0, new Intent(\"com.alarm.example\"),0 );\r\n        alarmManager = (AlarmManager)(this.getSystemService( Context.ALARM_SERVICE ));\r\n    }\r\n\r\n    /**\r\n     * At first start of the app the user has to accept the data protection regulations before he can\r\n     * use the app\r\n     */\r\n    public boolean firstAppStart() {\r\n        SharedPreferences preferences = getSharedPreferences(prefDataProtection, MODE_PRIVATE);\r\n        if (preferences.getBoolean(prefDataProtection, true)) {\r\n            SharedPreferences.Editor editor = preferences.edit();\r\n            editor.putBoolean(prefDataProtection, false);\r\n            editor.commit();\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Request a new key from the server.\r\n     */\r\n    public void requestKey() {\r\n        Call<RequestedObject> call = retrofitService.requestKey();\r\n        RetryCallUtil.enqueueWithRetry(call, new Callback<RequestedObject>() {\r\n            @Override\r\n            public void onResponse(Call<RequestedObject> call, Response<RequestedObject> response) {\r\n                if (response.code() == 200) {\r\n                    RequestedObject requestedKey = response.body();\r\n                    // set the key\r\n                    Key.setKey(requestedKey.getKey());\r\n                    // log key\r\n                    Log.i(TAG, \"Key: \" + Key.getKey());\r\n                } else if (response.code() == 404) {\r\n                    Log.i(TAG, \"Key doesn't exist\");\r\n                }\r\n            }\r\n\r\n            @Override\r\n            public void onFailure(Call<RequestedObject> call, Throwable t) {\r\n                Log.w(TAG, Objects.requireNonNull(t.getMessage()));\r\n                noConnectionNotification();\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Report an infection by sending the current key to the server.\r\n     *\r\n     * @throws KeyNotRequestedException if this method is called before a key is requested\r\n     */\r\n    public void reportInfection() throws KeyNotRequestedException {\r\n        if (Key.getKey() == null) {\r\n            throw new KeyNotRequestedException(\"A key needs to be requested first\");\r\n        } else {\r\n            // prepare users key for report\r\n            HashMap<String, String> keyMap = new HashMap<>();\r\n            keyMap.put(\"key\", Key.getKey());\r\n            // prepare contact keys for report if user has had contact\r\n            if (LocalSafer.getKeyPairs() != null) {\r\n                StringBuilder contactDate = new StringBuilder();\r\n                StringBuilder contactKey = new StringBuilder();\r\n                for (int i = 0; i < LocalSafer.getKeyPairs().length; i++) {\r\n                    // don't append \"|\" on the fist circle\r\n                    if (i == 0) {\r\n                        contactDate.append(LocalSafer.getKeyPairs()[i].split(\"----\")[1]);\r\n                        contactKey.append(LocalSafer.getKeyPairs()[i].split(\"----\")[0]);\r\n                    } else {\r\n                        contactDate.append(\"|\").append(LocalSafer.getKeyPairs()[i].split(\"----\")[1]);\r\n                        contactKey.append(\"|\").append(LocalSafer.getKeyPairs()[i].split(\"----\")[0]);\r\n                    }\r\n                }\r\n                keyMap.put(\"contactDate\", contactDate.toString());\r\n                keyMap.put(\"contactKey\", contactKey.toString());\r\n            }\r\n            // send values to the server\r\n            Call<Void> call = retrofitService.reportInfection(keyMap);\r\n            RetryCallUtil.enqueueWithRetry(call, new Callback<Void>() {\r\n                @Override\r\n                public void onResponse(Call<Void> call, Response<Void> response) {\r\n                    if (response.code() == 200) {\r\n                        Log.i(TAG, \"Infection reported successfully\");\r\n                    } else if (response.code() == 400) {\r\n                        Log.i(TAG, \"Infection already reported\");\r\n                    }\r\n                }\r\n\r\n                @Override\r\n                public void onFailure(Call<Void> call, Throwable t) {\r\n                    Log.w(TAG, Objects.requireNonNull(t.getMessage()));\r\n                    noConnectionNotification();\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    // standard notification if there is no connection to the server\r\n    private void noConnectionNotification() {\r\n        Intent retryRequestPushNotification = new Intent(MainActivity.this,\r\n                NotificationService.class);\r\n        retryRequestPushNotification.putExtra(\"TITLE\", \"Es konnte keine Verbindung zum Server hergestellt werden\");\r\n        retryRequestPushNotification.putExtra(\"TEXT\", \"Versuche Verbindungsaufbau in 5 Minuten erneut...\");\r\n        startService(retryRequestPushNotification);\r\n    }\r\n\r\n    /**\r\n     * Request all needed permissions based on SDK Version\r\n     * (Permission already requested in Manifest -> double check)\r\n     */\r\n    private void requestPermissions() {\r\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {\r\n            if (this.checkSelfPermission(Manifest.permission.ACCESS_FINE_LOCATION)\r\n                    == PackageManager.PERMISSION_GRANTED) {\r\n                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {\r\n                    if (this.checkSelfPermission(Manifest.permission.ACCESS_BACKGROUND_LOCATION)\r\n                            != PackageManager.PERMISSION_GRANTED) {\r\n                        if (!this.shouldShowRequestPermissionRationale(Manifest.permission.ACCESS_BACKGROUND_LOCATION)) {\r\n                            final AlertDialog.Builder builder = new AlertDialog.Builder(this);\r\n                            builder.setTitle(\"This app needs background location access\");\r\n                            builder.setMessage(\"Please grant location access so this app can detect beacons in the background.\");\r\n                            builder.setPositiveButton(android.R.string.ok, null);\r\n                            builder.setOnDismissListener(new DialogInterface.OnDismissListener() {\r\n\r\n                                @TargetApi(23)\r\n                                @Override\r\n                                public void onDismiss(DialogInterface dialog) {\r\n                                    requestPermissions(new String[]{Manifest.permission.ACCESS_BACKGROUND_LOCATION},\r\n                                            PERMISSION_REQUEST_BACKGROUND_LOCATION);\r\n                                }\r\n\r\n                            });\r\n                            builder.show();\r\n                        } else {\r\n                            final AlertDialog.Builder builder = new AlertDialog.Builder(this);\r\n                            builder.setTitle(\"Functionality limited\");\r\n                            builder.setMessage(\"Since background location access has not been granted, this app will not be able to discover beacons in the background.  Please go to Settings -> Applications -> Permissions and grant background location access to this app.\");\r\n                            builder.setPositiveButton(android.R.string.ok, null);\r\n                            builder.setOnDismissListener(new DialogInterface.OnDismissListener() {\r\n\r\n                                @Override\r\n                                public void onDismiss(DialogInterface dialog) {\r\n                                }\r\n\r\n                            });\r\n                            builder.show();\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                if (!this.shouldShowRequestPermissionRationale(Manifest.permission.ACCESS_FINE_LOCATION)) {\r\n                    requestPermissions(new String[]{Manifest.permission.ACCESS_FINE_LOCATION,\r\n                                    Manifest.permission.ACCESS_BACKGROUND_LOCATION},\r\n                            PERMISSION_REQUEST_FINE_LOCATION);\r\n                } else {\r\n                    final AlertDialog.Builder builder = new AlertDialog.Builder(this);\r\n                    builder.setTitle(\"Functionality limited\");\r\n                    builder.setMessage(\"Since location access has not been granted, this app will not be able to discover beacons.  Please go to Settings -> Applications -> Permissions and grant location access to this app.\");\r\n                    builder.setPositiveButton(android.R.string.ok, null);\r\n                    builder.setOnDismissListener(new DialogInterface.OnDismissListener() {\r\n\r\n                        @Override\r\n                        public void onDismiss(DialogInterface dialog) {\r\n                        }\r\n\r\n                    });\r\n                    builder.show();\r\n                }\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Verify if Bluetooth is turned on and if BLE is supported\r\n     */\r\n    private void verifyBluetooth() {\r\n        try {\r\n            if (!BeaconManager.getInstanceForApplication(this).checkAvailability()) {\r\n                final AlertDialog.Builder builder = new AlertDialog.Builder(this);\r\n                builder.setTitle(\"Bluetooth not enabled\");\r\n                builder.setMessage(\"Please enable bluetooth in settings and restart this application.\");\r\n                builder.setPositiveButton(android.R.string.ok, null);\r\n                builder.setOnDismissListener(new DialogInterface.OnDismissListener() {\r\n                    @Override\r\n                    public void onDismiss(DialogInterface dialog) {\r\n                        //finish();\r\n                        //System.exit(0);\r\n                    }\r\n                });\r\n                builder.show();\r\n            }\r\n        } catch (RuntimeException e) {\r\n            final AlertDialog.Builder builder = new AlertDialog.Builder(this);\r\n            builder.setTitle(\"Bluetooth LE not available\");\r\n            builder.setMessage(\"Sorry, this device does not support Bluetooth LE.\");\r\n            builder.setPositiveButton(android.R.string.ok, null);\r\n            builder.setOnDismissListener(new DialogInterface.OnDismissListener() {\r\n\r\n                @Override\r\n                public void onDismiss(DialogInterface dialog) {\r\n                    //finish();\r\n                    //System.exit(0);\r\n                }\r\n\r\n            });\r\n            builder.show();\r\n\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Permission dialog result catch to follow further steps if not granted\r\n     * @param requestCode\r\n     * @param permissions\r\n     * @param grantResults\r\n     */\r\n    @Override\r\n    public void onRequestPermissionsResult(int requestCode,\r\n                                           String permissions[], int[] grantResults) {\r\n        switch (requestCode) {\r\n            case PERMISSION_REQUEST_FINE_LOCATION: {\r\n                if (grantResults[0] == PackageManager.PERMISSION_GRANTED) {\r\n                    Log.d(TAG, \"fine location permission granted\");\r\n                } else {\r\n                    final AlertDialog.Builder builder = new AlertDialog.Builder(this);\r\n                    builder.setTitle(\"Functionality limited\");\r\n                    builder.setMessage(\"Since location access has not been granted, this app will not be able to discover beacons.\");\r\n                    builder.setPositiveButton(android.R.string.ok, null);\r\n                    builder.setOnDismissListener(new DialogInterface.OnDismissListener() {\r\n\r\n                        @Override\r\n                        public void onDismiss(DialogInterface dialog) {\r\n                        }\r\n\r\n                    });\r\n                    builder.show();\r\n                }\r\n                return;\r\n            }\r\n            case PERMISSION_REQUEST_BACKGROUND_LOCATION: {\r\n                if (grantResults[0] == PackageManager.PERMISSION_GRANTED) {\r\n                    Log.d(TAG, \"background location permission granted\");\r\n                } else {\r\n                    final AlertDialog.Builder builder = new AlertDialog.Builder(this);\r\n                    builder.setTitle(\"Functionality limited\");\r\n                    builder.setMessage(\"Since background location access has not been granted, this app will not be able to discover beacons when in the background.\");\r\n                    builder.setPositiveButton(android.R.string.ok, null);\r\n                    builder.setOnDismissListener(new DialogInterface.OnDismissListener() {\r\n\r\n                        @Override\r\n                        public void onDismiss(DialogInterface dialog) {\r\n                        }\r\n\r\n                    });\r\n                    builder.show();\r\n                }\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * create channel for the notification to be delivered as heads-up notification\r\n     */\r\n    private void createNotificationChannel() {\r\n        // Create the NotificationChannel (only on API 26+ because\r\n        // the NotificationChannel class is new and not in the support library)\r\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\r\n            CharSequence name = getString(R.string.channel_name);\r\n            String description = getString(R.string.channel_description);\r\n            int importance = NotificationManager.IMPORTANCE_HIGH; //high priority for heads-up notifications for android 8.0 and higher\r\n            NotificationChannel channel = new NotificationChannel(CHANNEL_ID, name, importance);\r\n            channel.setDescription(description);\r\n            // Register the channel with the system; you can't change the importance\r\n            // or other notification behaviors after this\r\n            notificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);\r\n            notificationManager.createNotificationChannel(channel);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Safes the own key in the shared preferences.\r\n     * @param key the own key as String\r\n     */\r\n    public void safeOwnKey(String key) {\r\n        SharedPreferences prefs = getPreferences(Context.MODE_PRIVATE);\r\n        SharedPreferences.Editor meinEditor = prefs.edit();\r\n        meinEditor.putString(\"ownKey\", key);\r\n        meinEditor.apply();\r\n    }\r\n\r\n\r\n    /**\r\n     * Getter for the own key out of the shared preferences\r\n     * @return the own key as String\r\n     */\r\n    public String getOwnKey() {\r\n        SharedPreferences prefs = getPreferences(Context.MODE_PRIVATE);\r\n        return prefs.getString(\"ownKey\", null);\r\n    }\r\n\r\n\r\n    /**\r\n     * method called daily to show the right traffic light status (for current health risk)\r\n     */\r\n    public static void showTrafficLightStatus() {\r\n        int riskValue = LocalSafer.getRiskLevel();\r\n        if(riskValue <= 33) {\r\n            trafficLight.setImageResource(R.drawable.green_traffic_light);\r\n        }\r\n        else if(riskValue <=70) {\r\n            trafficLight.setImageResource(R.drawable.yellow_traffic_light);\r\n        }\r\n        else {\r\n            trafficLight.setImageResource(R.drawable.red_traffic_light);\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * method called daily to show the right health risk status\r\n     */\r\n    public static void showRiskStatus(){\r\n        int riskValue = LocalSafer.getRiskLevel();\r\n        if(riskValue <= 33) {\r\n            riskStatus.setText(riskValue + \": Geringes Risiko\");\r\n        }\r\n        else if(riskValue <=70) {\r\n            riskStatus.setText(riskValue + \": Moderates Risiko\");\r\n        }\r\n        else {\r\n            riskStatus.setText(riskValue + \": Hohes Risiko\");\r\n        }\r\n    }\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/de/monokel/frontend/MainActivity.java	(revision 161fcba79a7cd8a3063de4224b496b454d354ae9)
+++ app/src/main/java/de/monokel/frontend/MainActivity.java	(date 1604568626514)
@@ -27,14 +27,20 @@
 
 import org.altbeacon.beacon.BeaconManager;
 
+import java.text.DateFormat;
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
 import java.util.Calendar;
+import java.util.Date;
 import java.util.HashMap;
 import java.util.Objects;
+import java.util.concurrent.TimeUnit;
 
 import de.monokel.frontend.exceptions.KeyNotRequestedException;
 import de.monokel.frontend.provider.Alarm;
 import de.monokel.frontend.provider.Key;
-import de.monokel.frontend.provider.LocalSafer;
+import de.monokel.frontend.provider.LocalDateSafer;
+import de.monokel.frontend.provider.LocalRiskLevelSafer;
 import de.monokel.frontend.provider.NotificationService;
 import de.monokel.frontend.provider.RequestedObject;
 import de.monokel.frontend.provider.RetrofitService;
@@ -50,6 +56,8 @@
  *
  * @author Tabea leibl
  * @author Philipp Alessandrini, Mergim Miftari, Nico Martin
+ * @author Philipp Alessandrini, Mergim Miftari
+ * @author Jonas
  * @version 2020-11-03
  */
 public class MainActivity extends AppCompatActivity {
@@ -61,7 +69,6 @@
     public static final String CHANNEL_ID = "pushNotifications";
     private NotificationManager notificationManager;
 
-    // for client-server-communication
     private Retrofit retrofit;
     private RetrofitService retrofitService;
     private String BASE_URL = "http://10.0.2.2:3000"; // for emulated phone
@@ -79,6 +86,7 @@
     //To display the current risk status
     private static ImageView trafficLight;
     private static TextView riskStatus;
+    private static TextView daysSinceFirstUseTextview;
 
 
     String prefDataProtection = "ausstehend";
@@ -91,6 +99,8 @@
         //traffic light image view and risk status text view
         this.trafficLight = (ImageView) this.findViewById(R.id.trafficLightView);
         this.riskStatus = (TextView) this.findViewById(R.id.RiskView);
+        this.daysSinceFirstUseTextview = (TextView) this.findViewById(R.id.ViewDaysUse);
+
 
         //Check bluetooth and location turned on
         verifyBluetooth();
@@ -111,6 +121,10 @@
         showTrafficLightStatus();
         showRiskStatus();
 
+        //show current Info about days since usage.
+        showDaysSinceUse();
+
+
         //If the app is opened for the first time the user has to accept the data protection regulations
         if (firstAppStart()) {
             Intent nextActivity = new Intent(MainActivity.this, DataProtectionActivity.class);
@@ -158,6 +172,8 @@
             testMenuButton.setOnClickListener(new View.OnClickListener() {
                 @Override
                 public void onClick(View v) {
+                    // request a key
+                    requestKey();
                     //Go to test menu screen
                     Intent nextActivity = new Intent(MainActivity.this, TestMenuActivity.class);
                     startActivity(nextActivity);
@@ -190,21 +206,20 @@
         }
 
         //Register AlarmManager Broadcast receive. (For the once-a-day-alarm-clock for deleting keys older then 3 weeks.
-        firingCal= Calendar.getInstance();
+        firingCal = Calendar.getInstance();
         firingCal.set(Calendar.HOUR, 8); // alarm hour
         firingCal.set(Calendar.MINUTE, 0); // alarm minute
         firingCal.set(Calendar.SECOND, 0); // and alarm second
         long intendedTime = firingCal.getTimeInMillis();
 
         registerMyAlarmBroadcast();
-        alarmManager.setRepeating( AlarmManager.RTC_WAKEUP, intendedTime , AlarmManager.INTERVAL_DAY , myPendingIntent );
+        alarmManager.setRepeating(AlarmManager.RTC_WAKEUP, intendedTime, AlarmManager.INTERVAL_DAY, myPendingIntent);
     }
 
     /**
      * This method supports the once-a-day-alarm-clock for deleting keys older then 3 weeks.
      */
-    private void registerMyAlarmBroadcast()
-    {
+    private void registerMyAlarmBroadcast() {
         //This is the call back function(BroadcastReceiver) which will be call when your
         //alarm time will reached.
         myBroadcastReceiver = new BroadcastReceiver() {
@@ -214,9 +229,9 @@
             }
         };
 
-        registerReceiver(myBroadcastReceiver, new IntentFilter("com.alarm.example") );
-        myPendingIntent = PendingIntent.getBroadcast( this, 0, new Intent("com.alarm.example"),0 );
-        alarmManager = (AlarmManager)(this.getSystemService( Context.ALARM_SERVICE ));
+        registerReceiver(myBroadcastReceiver, new IntentFilter("com.alarm.example"));
+        myPendingIntent = PendingIntent.getBroadcast(this, 0, new Intent("com.alarm.example"), 0);
+        alarmManager = (AlarmManager) (this.getSystemService(Context.ALARM_SERVICE));
     }
 
     /**
@@ -225,6 +240,10 @@
      */
     public boolean firstAppStart() {
         SharedPreferences preferences = getSharedPreferences(prefDataProtection, MODE_PRIVATE);
+        //generate and save the Date of the first app Start, maybe this code should be relocated.
+        LocalDateSafer.safeDateOfFirstAppStart(getCurrentDate());
+
+
         if (preferences.getBoolean(prefDataProtection, true)) {
             SharedPreferences.Editor editor = preferences.edit();
             editor.putBoolean(prefDataProtection, false);
@@ -271,27 +290,10 @@
         if (Key.getKey() == null) {
             throw new KeyNotRequestedException("A key needs to be requested first");
         } else {
-            // prepare users key for report
             HashMap<String, String> keyMap = new HashMap<>();
+            keyMap.put("date", Calendar.getInstance().getTime().toString());
             keyMap.put("key", Key.getKey());
-            // prepare contact keys for report if user has had contact
-            if (LocalSafer.getKeyPairs() != null) {
-                StringBuilder contactDate = new StringBuilder();
-                StringBuilder contactKey = new StringBuilder();
-                for (int i = 0; i < LocalSafer.getKeyPairs().length; i++) {
-                    // don't append "|" on the fist circle
-                    if (i == 0) {
-                        contactDate.append(LocalSafer.getKeyPairs()[i].split("----")[1]);
-                        contactKey.append(LocalSafer.getKeyPairs()[i].split("----")[0]);
-                    } else {
-                        contactDate.append("|").append(LocalSafer.getKeyPairs()[i].split("----")[1]);
-                        contactKey.append("|").append(LocalSafer.getKeyPairs()[i].split("----")[0]);
-                    }
-                }
-                keyMap.put("contactDate", contactDate.toString());
-                keyMap.put("contactKey", contactKey.toString());
-            }
-            // send values to the server
+
             Call<Void> call = retrofitService.reportInfection(keyMap);
             RetryCallUtil.enqueueWithRetry(call, new Callback<Void>() {
                 @Override
@@ -429,6 +431,7 @@
 
     /**
      * Permission dialog result catch to follow further steps if not granted
+     *
      * @param requestCode
      * @param permissions
      * @param grantResults
@@ -499,6 +502,7 @@
 
     /**
      * Safes the own key in the shared preferences.
+     *
      * @param key the own key as String
      */
     public void safeOwnKey(String key) {
@@ -508,9 +512,75 @@
         meinEditor.apply();
     }
 
+    /**
+     * Saves the date of the first app start in the shared preferences.
+     *
+     * @param string date
+     */
+    public void safeDateOfFirstAppStart(String string) {
+        SharedPreferences prefs = getPreferences(Context.MODE_PRIVATE);
+        SharedPreferences.Editor meinEditor = prefs.edit();
+        meinEditor.putString("dateOfFirstAppStart", string);
+        meinEditor.apply();
+    }
+
+    /**
+     * Getter for the date of the first app start in the shared preferences.
+     *
+     * @return
+     */
+    public String getDateOfFirstAppStart() {
+        SharedPreferences prefs = getPreferences(Context.MODE_PRIVATE);
+        String string = prefs.getString("dateOfFirstAppStart", null);
+        //Date date = new SimpleDateFormat("dd/MM/yyyy").parse(string);
+        return string;
+    }
+
+    /**
+     * Getter of the current date when this method is used
+     *
+     * @return
+     */
+
+    public static String getCurrentDate() {
+
+        Date currentDate = Calendar.getInstance().getTime();
+        String formattedDateString = DateFormat.getDateInstance().format(currentDate);
+
+        //Log.d("Jonas Log", currentDate.toString());
+        //Log.d("Jonas Log", formattedDateString);
+
+        return formattedDateString;
+    }
+
+    /**
+     * Methode berechnet den Abstand zwischen dem heutigen und dem Datum des ersten Starts der App
+     *
+     * @return
+     * @throws ParseException
+     */
+    public static long getDateDiffSinceFirstUse() {
+
+
+        Date firstAppStartDate = null;
+        try {
+            firstAppStartDate = new SimpleDateFormat("MMMM dd, yyyy").parse(LocalDateSafer.getDateOfFirstAppStart());
+        } catch (ParseException e) {
+            e.printStackTrace();
+            Log.d("Jonas Log", "Parse gone Wrong");
+        }
+
+        Date currentDate = new Date();
+
+        long diffInMillis = currentDate.getTime() - firstAppStartDate.getTime();
+        long dateDiffInDays = TimeUnit.DAYS.convert(diffInMillis, TimeUnit.MILLISECONDS);
+
+        return dateDiffInDays;
+    }
 
     /**
      * Getter for the own key out of the shared preferences
+     *
      * @return the own key as String
      */
     public String getOwnKey() {
@@ -518,36 +588,40 @@
         return prefs.getString("ownKey", null);
     }
 
+    public static String generateStringDaysSince() {
+        String daysSinceText = ("Seit dem " + LocalDateSafer.getDateOfFirstAppStart() + " helfen Sie, seit " + getDateDiffSinceFirstUse() + " Tagen, Corona einzudämmen.");
+        return daysSinceText;
+    }
+
+    public static void showDaysSinceUse() {
+        daysSinceFirstUseTextview.setText(generateStringDaysSince());
+
+    }
 
     /**
      * method called daily to show the right traffic light status (for current health risk)
      */
     public static void showTrafficLightStatus() {
-        int riskValue = LocalSafer.getRiskLevel();
-        if(riskValue <= 33) {
+        int riskValue = LocalRiskLevelSafer.getRiskLevel();
+        if (riskValue <= 33) {
             trafficLight.setImageResource(R.drawable.green_traffic_light);
-        }
-        else if(riskValue <=70) {
+        } else if (riskValue <= 70) {
             trafficLight.setImageResource(R.drawable.yellow_traffic_light);
-        }
-        else {
+        } else {
             trafficLight.setImageResource(R.drawable.red_traffic_light);
         }
     }
 
-
     /**
      * method called daily to show the right health risk status
      */
-    public static void showRiskStatus(){
-        int riskValue = LocalSafer.getRiskLevel();
-        if(riskValue <= 33) {
+    public static void showRiskStatus() {
+        int riskValue = LocalRiskLevelSafer.getRiskLevel();
+        if (riskValue <= 33) {
             riskStatus.setText(riskValue + ": Geringes Risiko");
-        }
-        else if(riskValue <=70) {
+        } else if (riskValue <= 70) {
             riskStatus.setText(riskValue + ": Moderates Risiko");
-        }
-        else {
+        } else {
             riskStatus.setText(riskValue + ": Hohes Risiko");
         }
     }
Index: app/src/main/java/de/monokel/frontend/provider/Alarm.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package de.monokel.frontend.provider;\r\n\r\nimport de.monokel.frontend.MainActivity;\r\n\r\n/**\r\n * This class has the method which is called once a day.\r\n *\r\n * @author Miftari, Leibl\r\n * @version 2020-11-02\r\n */\r\npublic class Alarm {\r\n\r\n    /**\r\n     * This method is called once a day.\r\n     */\r\n    public static void dailyBusiness() {\r\n        //delete all keys older then 3 weeks.\r\n        LocalSafer.addKeyPairToSavedKeyPairs(null);\r\n        LocalSafer.addNotificationToSavedNotifications(null);\r\n\r\n        //update current risk status (traffic light and risk status title) on main screen\r\n        MainActivity.showTrafficLightStatus();\r\n        MainActivity.showRiskStatus();\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/de/monokel/frontend/provider/Alarm.java	(revision 161fcba79a7cd8a3063de4224b496b454d354ae9)
+++ app/src/main/java/de/monokel/frontend/provider/Alarm.java	(date 1604568626644)
@@ -1,6 +1,9 @@
 package de.monokel.frontend.provider;
 
 import de.monokel.frontend.MainActivity;
+import de.monokel.frontend.risklevel.AmountOfContactsEnum;
+import de.monokel.frontend.risklevel.RiskLevel;
+import de.monokel.frontend.risklevel.TypeOfExposureEnum;
 
 /**
  * This class has the method which is called once a day.
@@ -15,11 +18,19 @@
      */
     public static void dailyBusiness() {
         //delete all keys older then 3 weeks.
-        LocalSafer.addKeyPairToSavedKeyPairs(null);
-        LocalSafer.addNotificationToSavedNotifications(null);
+        LocalKeySafer.addKeyPairToSavedKeyPairs(null);
+        LocalNotificationSafer.addNotificationToSavedNotifications(null);
+
+        //update the information about the date of the first usage and the days since the app is used
+        MainActivity.showDaysSinceUse();
+
+        //calculate and update the riskLevel
+        RiskLevel.updateRiskLevel(RiskLevel.calculateRiskLevel(TypeOfExposureEnum.NO_CONTACT), true);
 
         //update current risk status (traffic light and risk status title) on main screen
         MainActivity.showTrafficLightStatus();
         MainActivity.showRiskStatus();
+
+
     }
 }
Index: app/src/main/java/de/monokel/frontend/Constants.java
===================================================================
--- app/src/main/java/de/monokel/frontend/Constants.java	(revision 161fcba79a7cd8a3063de4224b496b454d354ae9)
+++ app/src/main/java/de/monokel/frontend/Constants.java	(revision 161fcba79a7cd8a3063de4224b496b454d354ae9)
@@ -1,16 +0,0 @@
-package de.monokel.frontend;
-
-public class Constants {
-    // Debug flag for testing purposes
-    public static final boolean DEBUG = true;
-    // Flag for controlling background scanning and transmitting (BLE Beacon)
-    // Set false if you try to run the app on a virtual device (emulator)
-    public static final boolean SCAN_AND_TRANSMIT = false;
-    // The time difference between device scans in ms
-    public static final Long BACKGROUND_SCAN_PERIOD = 1100L;
-    public static final Long FOREGROUND_SCAN_PERIOD = 1100L;
-    public static final String id1 = "01234567-0506-0708-090a-222222222222";
-    // 000000000000
-    // 111111111111
-    // 222222222222
-}
Index: app/src/main/java/de/monokel/frontend/provider/LocalSafer.java
===================================================================
--- app/src/main/java/de/monokel/frontend/provider/LocalSafer.java	(revision 161fcba79a7cd8a3063de4224b496b454d354ae9)
+++ app/src/main/java/de/monokel/frontend/provider/LocalSafer.java	(revision 161fcba79a7cd8a3063de4224b496b454d354ae9)
@@ -1,276 +0,0 @@
-package de.monokel.frontend.provider;
-
-import android.content.Context;
-
-import java.io.FileInputStream;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Date;
-import java.util.List;
-
-import de.monokel.frontend.keytransfer.BeaconBackgroundService;
-
-/**
- * This is the class for persistent saving of data at the client-side.
- *
- * @author Miftari
- * @version Nov 2020
- */
-public class LocalSafer {
-    private static String DATAFILE01 = "cowappkeys.txt";
-    private static String DATAFILE02 = "cowappnotifications.txt";
-    private static String DATAFILE03 = "cowapprisklevel.txt";
-    private static String DATAFILE04 = "cowappdaysslc.txt";
-    private static String DATAFILE05 = "cowappfirstdate.txt";
-
-    /**
-     * This methods saves a String under a datafileName.
-     * If there is not such datafile, it will be created, when you call this methode.
-     * @param datafile The Name of the datafile.
-     * @param value The String.
-     */
-    private static void safeStringAtDatafile(String datafile, String value) {
-        try {
-            FileOutputStream data = BeaconBackgroundService.getAppContext().openFileOutput(datafile,
-                    Context.MODE_PRIVATE);
-            data.write(value.getBytes());
-            data.close();
-        } catch (IOException ex) {
-            System.out.println("Some Mistakes happened at safeStringAtDatafile(...)");
-        }
-    }
-
-    /**
-     * Returns the value of a Datafile. If there is no such datafile, the returnvalue is an empty string.
-     * @param datafileName the name of the datafile.
-     * @return the value of the datafile.
-     */
-    private static String readDataFile(String datafileName) {
-        try {
-            FileInputStream datafile = BeaconBackgroundService.getAppContext().openFileInput(datafileName);
-            List<Byte> data = new ArrayList<Byte>();
-
-            while(true) {
-                int b = datafile.read();
-                if(b == -1) {
-                    break; // end of the datafile.
-                } else {
-                    data.add((byte) b);
-                }
-            }
-            // Bytes to words
-            byte[] bytes = new byte[data.size()];
-
-            for(int i = 0; i < bytes.length; i++) {
-                bytes[i] = data.get(i);
-            }
-
-            String text = new String(bytes);
-            return text;
-        } catch(Exception ex) { //datafile not found
-            return "";
-        }
-    }
-
-    /**
-     * Returns true if the date is older than 3 weeks.
-     * @param date
-     * @return
-     */
-    private static boolean dateIsOld(Date date) {
-        boolean result = false;
-        Date currentDate = new Date();
-
-        int currentMonth = currentDate.getMonth();
-        int currentDay = currentDate.getDay();
-        int oldMonth = date.getMonth();
-        int oldDay = date.getDay();
-
-        if (currentMonth != oldMonth) {
-            int days = 0;
-
-            switch (oldMonth) {
-                case 1:
-                case 7:
-                case 3:
-                case 5:
-                case 8:
-                case 10:
-                case 12:
-                    days = 31;
-                    break;
-
-                case 4:
-                case 6:
-                case 9:
-                case 11:
-                    days = 30;
-                    break;
-
-                case 2:
-                    days = 28;
-                    break;
-            }
-
-            if (((days - oldDay) + currentDay) > 21) {
-                result = true;
-            }
-        }
-        return result;
-    }
-
-    /**
-     * This Method returns an Array of Strings.
-     * The format of the Strings is the following:
-     * value + "----" + new Date().toString()
-     * @return A list of Strings. If there are no saved keys, the return-value is null.
-     */
-    private static String[] getValuesAsArray(String datafileName) {
-        String values = readDataFile(datafileName);
-        if (values.equals("")) {
-            return null;
-        }
-        values = values.substring(4);
-        return values.split("-<>-");
-    }
-
-    /**
-     * All Values older than 3 weeks are going to be deleted.
-     */
-    private static void deleteOldValues(String datafileName) {
-        String[] values = getValuesAsArray(datafileName);
-        String result = "";
-
-        if (values != null) {
-            for (String string : values) {
-                String[] strings = string.split("----");
-                Date dateOfValue = new Date(strings[1]);
-                if (!dateIsOld(dateOfValue)) {
-                    result = result + "-<>-" + string;
-                }
-            }
-
-            safeStringAtDatafile(datafileName, result);
-        }
-    }
-
-    /**
-     * safes the given key and the time of the method-call. If the parameter is null, the method deleteOldKeyPairs() is called.
-     * @param contactKey The Key of the contact
-     */
-    public synchronized static void addKeyPairToSavedKeyPairs(String contactKey) {
-        if (contactKey == null) {
-            deleteOldValues(DATAFILE01);
-        } else {
-            String alreadySavedKeyPairs = readDataFile(DATAFILE01);
-            String allKeyPairsToSafe = alreadySavedKeyPairs + "-<>-" + contactKey + "----" + new Date().toString();
-            safeStringAtDatafile(DATAFILE01, allKeyPairsToSafe);
-        }
-    }
-
-    /**
-     * This method clears the keyPairDataFile.
-     */
-    public static void clearKeyPairDataFile() {
-        safeStringAtDatafile(DATAFILE01, "");
-    }
-
-    /**
-     * This Method returns an Array of Strings.
-     * The format of the Strings is the following:
-     * contactKey + "----" + new Date().toString()
-     * @return A list of Strings. If there are no saved keys, the return-value is null.
-     */
-    public static String[] getKeyPairs() {
-        return getValuesAsArray(DATAFILE01);
-    }
-
-    /**
-     * safes the given notification and the time of the method-call. If the parameter is null, the method deleteOldNotifications() is called.
-     * @param notification The new notification as String
-     */
-    public synchronized static void addNotificationToSavedNotifications(String notification) {
-        if (notification == null) {
-            deleteOldValues(DATAFILE02);
-        } else {
-            String alreadySavedNotifications = readDataFile(DATAFILE02);
-            String allNotificationsToSafe = alreadySavedNotifications + "-<>-" + notification + "----" + new Date().toString();
-
-            safeStringAtDatafile(DATAFILE02, allNotificationsToSafe);
-        }
-    }
-
-    /**
-     * This method clears the Notifications-Datafile.
-     */
-    public static void clearNotificationDataFile() {
-        safeStringAtDatafile(DATAFILE02, "");
-    }
-
-    /**
-     * This Method returns an Array of Strings (the notifications).
-     * The format of the Strings is the following:
-     * Notification + "----" + new Date().toString()
-     * @return A list of Strings. If there are no saved notifications, the return-value is null.
-     */
-    public static String[] getNotifications() {
-        return getValuesAsArray(DATAFILE02);
-    }
-
-    /**
-     * Safes the risk Level.
-     * @param riskLevel risk level as int
-     */
-    public static void safeRiskLevel(int riskLevel) {
-        safeStringAtDatafile(DATAFILE03, String.valueOf(riskLevel));
-    }
-
-    /**
-     * Getter for the risk level.
-     * @return risk level as int.
-     */
-    public static int getRiskLevel() {
-        try {
-            return Integer.valueOf(readDataFile(DATAFILE03));
-        } catch(Exception ex) { //datafile not found
-            return 0;
-        }
-    }
-
-    /**
-     * Safes the daysSinceLastContact.
-     * @param daysSinceLastContact days Since last contact as int.
-     */
-    public static void safeDaysSinceLastContact(int daysSinceLastContact) {
-        safeStringAtDatafile(DATAFILE04, String.valueOf(daysSinceLastContact));
-    }
-
-    /**
-     * Getter for the daysSinceLastContact.
-     * @return the days since last Contact as int.
-     */
-    public static int getDaysSinceLastContact() {
-        try {
-            return Integer.valueOf(readDataFile(DATAFILE04));
-        } catch(Exception ex) { //datafile not found
-            return 0;
-        }
-    }
-
-    /**
-     * Safes the date of the first start.
-     * @param date days Since last contact as int.
-     */
-    public static void safeFirstStartDate(String date) {
-        safeStringAtDatafile(DATAFILE05, date);
-    }
-
-    /**
-     * Getter for the date of the first start.
-     * @return the days since last Contact as int.
-     */
-    public static String getFirstStartDate() {
-        return readDataFile(DATAFILE05);
-    }
-}
Index: app/src/main/java/de/monokel/frontend/TestMenuActivity.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package de.monokel.frontend;\r\n\r\nimport android.content.Intent;\r\nimport android.os.Bundle;\r\nimport android.view.View;\r\nimport android.widget.Button;\r\nimport android.widget.ImageButton;\r\n\r\nimport de.monokel.frontend.provider.LocalSafer;\r\nimport de.monokel.frontend.provider.NotificationService;\r\n\r\n/**\r\n * Developer menu to test functions for the CoWApp development\r\n *\r\n * @author Tabea leibl\r\n * @author Philipp Alessandrini\r\n * @version 2020-10-28\r\n */\r\npublic class TestMenuActivity extends MainActivity {\r\n\r\n    private static final int riskLevelTestValue = 50;\r\n\r\n    @Override\r\n    protected void onCreate(Bundle savedInstanceState) {\r\n        super.onCreate(savedInstanceState);\r\n        setContentView(R.layout.activity_test_menu);\r\n\r\n        //Back button listener\r\n        ImageButton backButton = (ImageButton)findViewById(R.id.backButtonTest);\r\n\r\n        backButton.setOnClickListener(new View.OnClickListener() {\r\n            @Override\r\n            public void onClick(View v) {\r\n                //Go to main screen\r\n                Intent nextActivity = new Intent(TestMenuActivity.this,MainActivity.class);\r\n                startActivity(nextActivity);\r\n            }\r\n        });\r\n\r\n        //Push notification test button listener\r\n        Button pushTestButton = (Button)findViewById(R.id.Test1);\r\n\r\n        pushTestButton.setOnClickListener(new View.OnClickListener() {\r\n            @Override\r\n            public void onClick(View v) {\r\n                //trigger push notification to test its functionality\r\n                Intent pushNotificationActivity = new Intent(TestMenuActivity.this, NotificationService.class);\r\n                pushNotificationActivity.putExtra(\"TITLE\", \"Mögliches Gesundheitsrisiko\");\r\n                pushNotificationActivity.putExtra(\"TEXT\", \"Hier klicken für weitere Informationen.\");\r\n                pushNotificationActivity.putExtra(\"CLASS\", PushNotificationActivity.class);\r\n                startService(pushNotificationActivity);\r\n            }\r\n        });\r\n\r\n        // Generate key test button listener\r\n        Button generateKeyTestButton = (Button)findViewById(R.id.Test2);\r\n\r\n        generateKeyTestButton.setOnClickListener(new View.OnClickListener() {\r\n            @Override\r\n            public void onClick(View v) {\r\n                // try to generate a key if the smartphone has a connection to the server\r\n                requestKey();\r\n            }\r\n        });\r\n\r\n        // Risk level test button listener\r\n        Button riskLevelTestButton = (Button)findViewById(R.id.Test3);\r\n\r\n        riskLevelTestButton.setOnClickListener(new View.OnClickListener() {\r\n            @Override\r\n            public void onClick(View v) {\r\n                //change risk level and update shown status\r\n                LocalSafer.safeRiskLevel(riskLevelTestValue);\r\n                MainActivity.showRiskStatus();\r\n                MainActivity.showTrafficLightStatus();\r\n            }\r\n        });\r\n\r\n        // Reset button (for risk level test button) listener\r\n        Button resetButton = (Button)findViewById(R.id.resetButton);\r\n\r\n        resetButton.setOnClickListener(new View.OnClickListener() {\r\n            @Override\r\n            public void onClick(View v) {\r\n                //reset risk level to 0\r\n                LocalSafer.safeRiskLevel(0);\r\n            }\r\n        });\r\n    }\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/de/monokel/frontend/TestMenuActivity.java	(revision 161fcba79a7cd8a3063de4224b496b454d354ae9)
+++ app/src/main/java/de/monokel/frontend/TestMenuActivity.java	(date 1604568626558)
@@ -6,7 +6,7 @@
 import android.widget.Button;
 import android.widget.ImageButton;
 
-import de.monokel.frontend.provider.LocalSafer;
+import de.monokel.frontend.provider.LocalRiskLevelSafer;
 import de.monokel.frontend.provider.NotificationService;
 
 /**
@@ -70,7 +70,7 @@
             @Override
             public void onClick(View v) {
                 //change risk level and update shown status
-                LocalSafer.safeRiskLevel(riskLevelTestValue);
+                LocalRiskLevelSafer.safeRiskLevel(riskLevelTestValue);
                 MainActivity.showRiskStatus();
                 MainActivity.showTrafficLightStatus();
             }
@@ -83,7 +83,7 @@
             @Override
             public void onClick(View v) {
                 //reset risk level to 0
-                LocalSafer.safeRiskLevel(0);
+                LocalRiskLevelSafer.safeRiskLevel(0);
             }
         });
     }
Index: settings.gradle
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>include ':app'\r\nrootProject.name = \"frontend\"
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- settings.gradle	(revision 161fcba79a7cd8a3063de4224b496b454d354ae9)
+++ settings.gradle	(date 1604568626577)
@@ -1,2 +1,3 @@
+include ':jonasLib'
 include ':app'
 rootProject.name = "frontend"
\ No newline at end of file
Index: .idea/gradle.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"GradleMigrationSettings\" migrationVersion=\"1\" />\r\n  <component name=\"GradleSettings\">\r\n    <option name=\"linkedExternalProjectsSettings\">\r\n      <GradleProjectSettings>\r\n        <option name=\"testRunner\" value=\"PLATFORM\" />\r\n        <option name=\"distributionType\" value=\"DEFAULT_WRAPPED\" />\r\n        <option name=\"externalProjectPath\" value=\"$PROJECT_DIR$\" />\r\n        <option name=\"gradleHome\" value=\"$PROJECT_DIR$/../../../../Program Files/Gradle/gradle-6.3\" />\r\n        <option name=\"gradleJvm\" value=\"1.8\" />\r\n        <option name=\"modules\">\r\n          <set>\r\n            <option value=\"$PROJECT_DIR$\" />\r\n            <option value=\"$PROJECT_DIR$/app\" />\r\n          </set>\r\n        </option>\r\n        <option name=\"resolveModulePerSourceSet\" value=\"false\" />\r\n        <option name=\"useQualifiedModuleNames\" value=\"true\" />\r\n      </GradleProjectSettings>\r\n    </option>\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/gradle.xml	(revision 161fcba79a7cd8a3063de4224b496b454d354ae9)
+++ .idea/gradle.xml	(date 1604568626501)
@@ -7,12 +7,13 @@
         <option name="testRunner" value="PLATFORM" />
         <option name="distributionType" value="DEFAULT_WRAPPED" />
         <option name="externalProjectPath" value="$PROJECT_DIR$" />
-        <option name="gradleHome" value="$PROJECT_DIR$/../../../../Program Files/Gradle/gradle-6.3" />
+        <option name="gradleHome" value="D:/../Program Files/Gradle/gradle-6.3" />
         <option name="gradleJvm" value="1.8" />
         <option name="modules">
           <set>
             <option value="$PROJECT_DIR$" />
             <option value="$PROJECT_DIR$/app" />
+            <option value="$PROJECT_DIR$/jonasLib" />
           </set>
         </option>
         <option name="resolveModulePerSourceSet" value="false" />
Index: server/utils/reset_database.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/**\r\n * Util-Script which resets the Key-Counter to 0.\r\n *\r\n * @author Mergim Miftari\r\n * @author Philipp Alessandrini\r\n * @version 2020-10-29\r\n */\r\n\r\n// init mongoDB\r\nconst MongoClient = require('mongodb').MongoClient;\r\nconst url = \"mongodb+srv://admin:zyI8ZX5zmAyfjaVt@cowapp.9hh4n.mongodb.net/CoWApp?retryWrites=true&w=majority\";\r\n\r\n// connect to the database\r\nMongoClient.connect(url, { useUnifiedTopology: true }, async function(err, db) {\r\n    if (err) {\r\n        console.log(\"Error while connecting mongo client\");\r\n    } else {\r\n        // define db and collections which are going to be reset\r\n        const cowappDb = db.db('CoWAppDB');\r\n        const keyCollection = cowappDb.collection('key');\r\n        const infectedCollection = cowappDb.collection('infected');\r\n        const keyPairsCollection = cowappDb.collection('key_pairs');\r\n        // reset key-counter in 'key' collection\r\n        const zerocounter = { $set: {key: \"0\"} };\r\n        await keyCollection.updateOne({}, zerocounter, function(err, res) {\r\n            if (err) throw err;\r\n            console.log(\"Key-Counter successfully reset\");\r\n        });\r\n        // drop 'infected' collection\r\n        await infectedCollection.drop(function(err, delOK) {\r\n            if (err) console.log(\"There are no infected keys reported at the moment\");\r\n            if (delOK) console.log(\"Infected keys successfully deleted\");\r\n        });\r\n        // drop 'key_pairs' collection\r\n        await keyPairsCollection.drop(function(err, delOK) {\r\n            if (err) console.log(\"There are no key pairs reported at the moment\");\r\n            if (delOK) console.log(\"Key pairs successfully deleted\");\r\n            db.close();\r\n        });\r\n    }\r\n});
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- server/utils/reset_database.js	(revision 161fcba79a7cd8a3063de4224b496b454d354ae9)
+++ server/utils/reset_database.js	(date 1604568626595)
@@ -3,7 +3,7 @@
  *
  * @author Mergim Miftari
  * @author Philipp Alessandrini
- * @version 2020-10-29
+ * @version 2020-10-21
  */
 
 // init mongoDB
@@ -15,11 +15,9 @@
     if (err) {
         console.log("Error while connecting mongo client");
     } else {
-        // define db and collections which are going to be reset
         const cowappDb = db.db('CoWAppDB');
         const keyCollection = cowappDb.collection('key');
         const infectedCollection = cowappDb.collection('infected');
-        const keyPairsCollection = cowappDb.collection('key_pairs');
         // reset key-counter in 'key' collection
         const zerocounter = { $set: {key: "0"} };
         await keyCollection.updateOne({}, zerocounter, function(err, res) {
@@ -30,11 +28,6 @@
         await infectedCollection.drop(function(err, delOK) {
             if (err) console.log("There are no infected keys reported at the moment");
             if (delOK) console.log("Infected keys successfully deleted");
-        });
-        // drop 'key_pairs' collection
-        await keyPairsCollection.drop(function(err, delOK) {
-            if (err) console.log("There are no key pairs reported at the moment");
-            if (delOK) console.log("Key pairs successfully deleted");
             db.close();
         });
     }
Index: server/server.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/**\r\n * Server for CoWApp\r\n *\r\n * @author Mergim Miftari\r\n * @author Philipp Alessandrini\r\n * @version 2020-11-04\r\n */\r\n\r\n// init web framework\r\nconst express = require('express');\r\nconst app = express();\r\n// init mongoDB\r\nconst MongoClient = require('mongodb').MongoClient;\r\nconst url = \"mongodb+srv://admin:zyI8ZX5zmAyfjaVt@cowapp.9hh4n.mongodb.net/CoWApp?retryWrites=true&w=majority\";\r\n// enable json parsing\r\napp.use(express.json());\r\n\r\n// connect to the database\r\nMongoClient.connect(url, { useUnifiedTopology: true }, function(err, db) {\r\n    if (err) {\r\n        console.log(\"Error while connecting mongo client\");\r\n    } else {\r\n        // define db and collections\r\n        const cowappDb = db.db('CoWAppDB');\r\n        const keyCollection = cowappDb.collection('key');\r\n        const infectedCollection = cowappDb.collection('infected');\r\n        const keyPairsCollection = cowappDb.collection('key_pairs');\r\n        // request a key from mongodb\r\n        app.get('/request_key', (req, res) => {\r\n            keyCollection.findOne({}, (err, result) => {\r\n                if (result != null) {\r\n                    // get current key value from mongodb\r\n                    const oldKey = parseInt(result.key);\r\n                    // calculate a new key\r\n                    const newKey = (oldKey + 1).toString();\r\n                    // send new key to mongodb\r\n                    const sendKey = { $set: {key: newKey} };\r\n                    // check if current key is infected\r\n                    infectedCollection.findOne({key: oldKey.toString()}, function (err, result) {\r\n                        if (err) throw err;\r\n                        if (result != null) {\r\n                            // update new key\r\n                            infectedCollection.updateOne(result, sendKey);\r\n                        }\r\n                    });\r\n                    // check if current key has had contacts\r\n                    keyPairsCollection.findOne({key: oldKey.toString()}, function (err, result) {\r\n                        if (err) throw err;\r\n                        if (result != null) {\r\n                            // update new key\r\n                            keyPairsCollection.updateOne(result, sendKey);\r\n                        }\r\n                        // also check if current key is a contact\r\n                        keyPairsCollection.findOne({contactKey: oldKey.toString()}, function (err, result) {\r\n                            if (err) throw err;\r\n                            if (result != null) {\r\n                                // update new key\r\n                                keyPairsCollection.updateOne({contactKey: oldKey.toString()},\r\n                                    { $set: {'contactKey.$': newKey} });\r\n                            }\r\n                        });\r\n                    });\r\n                    // also update new unique key in mongodb\r\n                    keyCollection.updateOne({}, sendKey, (err, result) => {\r\n                        if (err) throw err;\r\n                        // send key to the client\r\n                        const requestedKey = { key: newKey };\r\n                        res.status(200).send(JSON.stringify(requestedKey));\r\n                    });\r\n                } else {\r\n                    // object not found\r\n                    res.status(404).send();\r\n                }\r\n            });\r\n        });\r\n        // send infected key to mongodb\r\n        app.post('/report_infection', (req, res) => {\r\n            // delete reported key after 14 days\r\n            infectedCollection.createIndex({ \"createdAt\": 1 }, { expireAfterSeconds: 14*24*60*60 });\r\n            // delete key pairs after 21 days\r\n            keyPairsCollection.createIndex({ \"createdAt\": 1 }, { expireAfterSeconds: 21*24*60*60 });\r\n            // pack a userReport const which will be sent to mongodb\r\n            const userReport = {\r\n                \"createdAt\": new Date(),\r\n                key: req.body.key\r\n            };\r\n            const searchKey = { key: userReport.key };\r\n            // search in the db if userKey is already existing\r\n            infectedCollection.findOne(searchKey, (err, result) => {\r\n                // add infected key if it's not already reported\r\n                if (result == null) {\r\n                    infectedCollection.insertOne(userReport, (err, result) => {\r\n                        if (err) throw err;\r\n                        // check if user also has had contacts and add contacts\r\n                        if (typeof req.body.contactDate !== 'undefined') {\r\n                            const contactReport = {\r\n                                \"createdAt\": new Date(),\r\n                                key: req.body.key,\r\n                                contactDate: req.body.contactDate.split(\"|\"),\r\n                                contactKey: req.body.contactKey.split(\"|\")\r\n                            }\r\n                            keyPairsCollection.insertOne(contactReport, (err, result) => {\r\n                                if (err) throw err;\r\n                            });\r\n                        }\r\n                        res.status(200).send();\r\n                    });\r\n                } else {\r\n                    // user has infection already reported\r\n                    res.status(400).send();\r\n                }\r\n            });\r\n        });\r\n    }\r\n});\r\n\r\n// start listening on port 3000\r\napp.listen(3000, () => {\r\n    console.log(\"Listening on port 3000...\");\r\n});
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- server/server.js	(revision 161fcba79a7cd8a3063de4224b496b454d354ae9)
+++ server/server.js	(date 1604568626602)
@@ -3,7 +3,7 @@
  *
  * @author Mergim Miftari
  * @author Philipp Alessandrini
- * @version 2020-11-04
+ * @version 2020-10-22
  */
 
 // init web framework
@@ -24,7 +24,6 @@
         const cowappDb = db.db('CoWAppDB');
         const keyCollection = cowappDb.collection('key');
         const infectedCollection = cowappDb.collection('infected');
-        const keyPairsCollection = cowappDb.collection('key_pairs');
         // request a key from mongodb
         app.get('/request_key', (req, res) => {
             keyCollection.findOne({}, (err, result) => {
@@ -35,7 +34,7 @@
                     const newKey = (oldKey + 1).toString();
                     // send new key to mongodb
                     const sendKey = { $set: {key: newKey} };
-                    // check if current key is infected
+                    // check if current key is infected and update infected key
                     infectedCollection.findOne({key: oldKey.toString()}, function (err, result) {
                         if (err) throw err;
                         if (result != null) {
@@ -43,24 +42,7 @@
                             infectedCollection.updateOne(result, sendKey);
                         }
                     });
-                    // check if current key has had contacts
-                    keyPairsCollection.findOne({key: oldKey.toString()}, function (err, result) {
-                        if (err) throw err;
-                        if (result != null) {
-                            // update new key
-                            keyPairsCollection.updateOne(result, sendKey);
-                        }
-                        // also check if current key is a contact
-                        keyPairsCollection.findOne({contactKey: oldKey.toString()}, function (err, result) {
-                            if (err) throw err;
-                            if (result != null) {
-                                // update new key
-                                keyPairsCollection.updateOne({contactKey: oldKey.toString()},
-                                    { $set: {'contactKey.$': newKey} });
-                            }
-                        });
-                    });
-                    // also update new unique key in mongodb
+                    // update new key in mongodb
                     keyCollection.updateOne({}, sendKey, (err, result) => {
                         if (err) throw err;
                         // send key to the client
@@ -77,32 +59,17 @@
         app.post('/report_infection', (req, res) => {
             // delete reported key after 14 days
             infectedCollection.createIndex({ "createdAt": 1 }, { expireAfterSeconds: 14*24*60*60 });
-            // delete key pairs after 21 days
-            keyPairsCollection.createIndex({ "createdAt": 1 }, { expireAfterSeconds: 21*24*60*60 });
-            // pack a userReport const which will be sent to mongodb
+            // get key from user
             const userReport = {
                 "createdAt": new Date(),
                 key: req.body.key
             };
             const searchKey = { key: userReport.key };
-            // search in the db if userKey is already existing
+            // search in the db if key is already existing
             infectedCollection.findOne(searchKey, (err, result) => {
-                // add infected key if it's not already reported
+                // add infected key if its not existing
                 if (result == null) {
                     infectedCollection.insertOne(userReport, (err, result) => {
-                        if (err) throw err;
-                        // check if user also has had contacts and add contacts
-                        if (typeof req.body.contactDate !== 'undefined') {
-                            const contactReport = {
-                                "createdAt": new Date(),
-                                key: req.body.key,
-                                contactDate: req.body.contactDate.split("|"),
-                                contactKey: req.body.contactKey.split("|")
-                            }
-                            keyPairsCollection.insertOne(contactReport, (err, result) => {
-                                if (err) throw err;
-                            });
-                        }
                         res.status(200).send();
                     });
                 } else {
Index: app/src/main/java/de/monokel/frontend/provider/LocalRiskLevelSafer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/de/monokel/frontend/provider/LocalRiskLevelSafer.java	(date 1604568626660)
+++ app/src/main/java/de/monokel/frontend/provider/LocalRiskLevelSafer.java	(date 1604568626660)
@@ -0,0 +1,114 @@
+package de.monokel.frontend.provider;
+
+import android.content.Context;
+
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+import de.monokel.frontend.keytransfer.BeaconBackgroundService;
+
+/**
+ * Safer for the Risk Level and the days since last contact
+ *
+ * @author Miftari
+ */
+public class LocalRiskLevelSafer {
+    /**
+     * Safes the risk Level.
+     *
+     * @param riskLevel risk level as int
+     */
+    public static void safeRiskLevel(int riskLevel) {
+        try {
+            FileOutputStream data = BeaconBackgroundService.getAppContext().openFileOutput("cowapprisklevel.txt",
+                    Context.MODE_PRIVATE);
+            data.write(String.valueOf(riskLevel).getBytes());
+            data.close();
+        } catch (IOException ex) {
+            System.out.println("Some Mistakes happened at safeRiskLevel");
+        }
+    }
+
+    /**
+     * Getter for the risk level.
+     *
+     * @return risk level as int.
+     */
+    public static int getRiskLevel() {
+        try {
+            FileInputStream datafile = BeaconBackgroundService.getAppContext().openFileInput("cowapprisklevel.txt");
+            List<Byte> data = new ArrayList<Byte>();
+
+            while (true) {
+                int b = datafile.read();
+                if (b == -1) {
+                    break; // end of the datafile.
+                } else {
+                    data.add((byte) b);
+                }
+            }
+            // Bytes to words
+            byte[] bytes = new byte[data.size()];
+
+            for (int i = 0; i < bytes.length; i++) {
+                bytes[i] = data.get(i);
+            }
+
+            String text = new String(bytes);
+            return Integer.valueOf(text);
+        } catch (Exception ex) { //datafile not found
+            return 0;
+        }
+    }
+
+    /**
+     * Safes the daysSinceLastContact.
+     *
+     * @param daysSinceLastContact days Since last contact as int.
+     */
+    public static void safeDaysSinceLastContact(int daysSinceLastContact) {
+        try {
+            FileOutputStream data = BeaconBackgroundService.getAppContext().openFileOutput("cowappdaysslc.txt",
+                    Context.MODE_PRIVATE);
+            data.write(String.valueOf(daysSinceLastContact).getBytes());
+            data.close();
+        } catch (IOException ex) {
+            System.out.println("Some Mistakes happened at safeDaysSinceLastContact");
+        }
+    }
+
+    /**
+     * Getter for the daysSinceLastContact.
+     *
+     * @return the days since last Contact as int.
+     */
+    public static int getDaysSinceLastContact() {
+        try {
+            FileInputStream datafile = BeaconBackgroundService.getAppContext().openFileInput("cowappdaysslc.txt");
+            List<Byte> data = new ArrayList<Byte>();
+
+            while (true) {
+                int b = datafile.read();
+                if (b == -1) {
+                    break; // end of the datafile.
+                } else {
+                    data.add((byte) b);
+                }
+            }
+            // Bytes to words
+            byte[] bytes = new byte[data.size()];
+
+            for (int i = 0; i < bytes.length; i++) {
+                bytes[i] = data.get(i);
+            }
+
+            String text = new String(bytes);
+            return Integer.valueOf(text);
+        } catch (Exception ex) { //datafile not found
+            return 0;
+        }
+    }
+}
Index: app/src/main/java/de/monokel/frontend/risklevel/TypeOfExposureEnum.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/de/monokel/frontend/risklevel/TypeOfExposureEnum.java	(date 1604568626629)
+++ app/src/main/java/de/monokel/frontend/risklevel/TypeOfExposureEnum.java	(date 1604568626629)
@@ -0,0 +1,13 @@
+package de.monokel.frontend.risklevel;
+
+/**
+ * Enum zur Klassifizierung der Art wie eine Übertragung stattgefunden haben könnte.
+ * Direct contact stellt einen Kontakt mit einer als infiziert gemeldeten Person da.
+ * Indirect Contact stellt einen Kontakt mit einer nicht als infiziert gemeldeten Person da. *
+ * Long und Short Exposure stellen dar ob es sich um lange oder kurze, bzw. entsprechend viele oder wenige Schlüssel ausgetauscht wurden.
+ *
+ * @author jonas
+ * 26.10.2020
+ */
+
+public enum TypeOfExposureEnum {LONG_EXPOSURE_DIRECT_CONTACT, SHORT_EXPOSURE_DIRECT_CONTACT, LONG_EXPOSURE_INDIRECT_CONTACT, SHORT_EXPOSURE_INDIRECT_CONTACT, NO_CONTACT}
Index: app/src/main/java/de/monokel/frontend/provider/LocalDateSafer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/de/monokel/frontend/provider/LocalDateSafer.java	(date 1604568626638)
+++ app/src/main/java/de/monokel/frontend/provider/LocalDateSafer.java	(date 1604568626638)
@@ -0,0 +1,63 @@
+package de.monokel.frontend.provider;
+
+import android.content.Context;
+
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+import de.monokel.frontend.keytransfer.BeaconBackgroundService;
+
+public class LocalDateSafer {
+
+    /**
+     * Safes the daysSinceLastContact.
+     *
+     * @param safeDateOfFirstAppStart days Since last contact as int.
+     */
+    public static void safeDateOfFirstAppStart(String safeDateOfFirstAppStart) {
+        try {
+            FileOutputStream data = BeaconBackgroundService.getAppContext().openFileOutput("cowappdaysslc.txt",
+                    Context.MODE_PRIVATE);
+            data.write(String.valueOf(safeDateOfFirstAppStart).getBytes());
+            data.close();
+        } catch (IOException ex) {
+            System.out.println("Some Mistakes happened at safeDaysSinceLastContact");
+        }
+    }
+
+
+    /**
+     * Getter for the DateOfFirstAppStart.
+     *
+     * @return the date of the first App Start
+     */
+    public static String getDateOfFirstAppStart() {
+        try {
+            FileInputStream datafile = BeaconBackgroundService.getAppContext().openFileInput("cowappdaysslc.txt");
+            List<Byte> data = new ArrayList<Byte>();
+
+            while (true) {
+                int b = datafile.read();
+                if (b == -1) {
+                    break; // end of the datafile.
+                } else {
+                    data.add((byte) b);
+                }
+            }
+            // Bytes to words
+            byte[] bytes = new byte[data.size()];
+
+            for (int i = 0; i < bytes.length; i++) {
+                bytes[i] = data.get(i);
+            }
+
+            String text = new String(bytes);
+            return text;
+        } catch (Exception ex) { //datafile not found
+            return "0";
+        }
+    }
+}
Index: app/src/main/java/de/monokel/frontend/keytransfer/BeaconBackgroundService.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package de.monokel.frontend.keytransfer;\r\n\r\nimport android.app.Application;\r\nimport android.app.Notification;\r\nimport android.app.NotificationChannel;\r\nimport android.app.NotificationManager;\r\nimport android.app.PendingIntent;\r\nimport android.app.TaskStackBuilder;\r\nimport android.bluetooth.le.AdvertiseCallback;\r\nimport android.bluetooth.le.AdvertiseSettings;\r\nimport android.content.Context;\r\nimport android.content.Intent;\r\nimport android.os.Build;\r\nimport android.os.RemoteException;\r\nimport android.util.Log;\r\n\r\nimport org.altbeacon.beacon.Beacon;\r\nimport org.altbeacon.beacon.BeaconConsumer;\r\nimport org.altbeacon.beacon.BeaconManager;\r\nimport org.altbeacon.beacon.BeaconParser;\r\nimport org.altbeacon.beacon.BeaconTransmitter;\r\nimport org.altbeacon.beacon.BuildConfig;\r\nimport org.altbeacon.beacon.RangeNotifier;\r\nimport org.altbeacon.beacon.Region;\r\nimport org.altbeacon.beacon.powersave.BackgroundPowerSaver;\r\nimport org.altbeacon.beacon.startup.BootstrapNotifier;\r\nimport org.altbeacon.beacon.startup.RegionBootstrap;\r\n\r\nimport java.util.Arrays;\r\nimport java.util.Collection;\r\n\r\nimport de.monokel.frontend.MainActivity;\r\nimport de.monokel.frontend.R;\r\nimport de.monokel.frontend.Constants;\r\n\r\n/**\r\n * BeaconBackgroundService that extends the Android Application so it starts when the Application is\r\n * first launched. From then on it will continue to scan for all BLE Beacons in the Background as a\r\n * foreground Service on Android 8+\r\n *\r\n * @author Nico Martin\r\n * @version 2020-11-02\r\n */\r\npublic class BeaconBackgroundService extends Application implements BootstrapNotifier, BeaconConsumer, RangeNotifier {\r\n\r\n    private static Context context;\r\n\r\n    private static final String TAG = \"BeaconBackgroundService\";\r\n    private RegionBootstrap regionBootstrap;\r\n    private BackgroundPowerSaver backgroundPowerSaver;\r\n    private BeaconManager beaconManager;\r\n\r\n    @Override\r\n    public void onCreate() {\r\n        super.onCreate();\r\n        Log.d(TAG, \"onCreate()\");\r\n        BeaconBackgroundService.context = getApplicationContext();\r\n\r\n        // Constants flag that disables scanning and transmitting so that development team doesn't\r\n        // have an App on their phone that constantly uses battery\r\n        if (Constants.SCAN_AND_TRANSMIT) {\r\n            beaconManager = org.altbeacon.beacon.BeaconManager.getInstanceForApplication(this);\r\n\r\n            // By default the AndroidBeaconLibrary will only find AltBeacons.  If you wish to make it\r\n            // find a different type of beacon, you must specify the byte layout for that beacon's\r\n            // advertisement with a line like below.  The example shows how to find a beacon with the\r\n            // same byte layout as AltBeacon but with a beaconTypeCode of 0xaabb.  To find the proper\r\n            // layout expression for other beacon types, do a web search for \"setBeaconLayout\"\r\n            // including the quotes.\r\n            beaconManager.getBeaconParsers().clear();\r\n            beaconManager.getBeaconParsers().add(new BeaconParser().\r\n                    setBeaconLayout(\"s:0-1=fd6f,p:-:-59,i:2-17,d:18-21\"));\r\n\r\n            // Uncomment the code below to use a foreground service to scan for beacons. This unlocks\r\n            // the ability to continually scan for long periods of time in the background on Andorid 8+\r\n            // in exchange for showing an icon at the top of the screen and a always-on notification to\r\n            // communicate to users that your app is using resources in the background.\r\n            Notification.Builder builder = new Notification.Builder(this);\r\n            builder.setSmallIcon(R.drawable.ic_launcher);\r\n            builder.setContentTitle(\"Scanning for Beacons\");\r\n            Intent intent = new Intent(this, MainActivity.class);\r\n            PendingIntent pendingIntent = PendingIntent.getActivity(\r\n                    this, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT\r\n            );\r\n            builder.setContentIntent(pendingIntent);\r\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\r\n                NotificationChannel channel = new NotificationChannel(\"My Notification Channel ID\",\r\n                        \"My Notification Name\", NotificationManager.IMPORTANCE_DEFAULT);\r\n                channel.setDescription(\"My Notification Channel Description\");\r\n                NotificationManager notificationManager = (NotificationManager) getSystemService(\r\n                        Context.NOTIFICATION_SERVICE);\r\n                notificationManager.createNotificationChannel(channel);\r\n                builder.setChannelId(channel.getId());\r\n            }\r\n            beaconManager.enableForegroundServiceScanning(builder.build(), 456);\r\n\r\n            // For the above foreground scanning service to be useful, you need to disable\r\n            // JobScheduler-based scans (used on Android 8+) and set a fast background scan\r\n            // cycle that would otherwise be disallowed by the operating system.\r\n            beaconManager.setEnableScheduledScanJobs(false);\r\n            beaconManager.setBackgroundBetweenScanPeriod(Constants.BACKGROUND_SCAN_PERIOD);\r\n            beaconManager.setForegroundBetweenScanPeriod(Constants.FOREGROUND_SCAN_PERIOD);\r\n\r\n\r\n            Log.d(TAG, \"setting up background monitoring for beacons and power saving\");\r\n            // wake up the app when a beacon is seen\r\n            Region region = new Region(\"backgroundRegion\", null, null, null);\r\n            regionBootstrap = new RegionBootstrap(this, region);\r\n\r\n            beaconManager.bind(this);\r\n            // simply constructing this class and holding a reference to it in your custom Application\r\n            // class will automatically cause the BeaconLibrary to save battery whenever the application\r\n            // is not visible.  This reduces bluetooth power usage by about 60%\r\n            backgroundPowerSaver = new BackgroundPowerSaver(this);\r\n\r\n            // This code block starts beacon transmission\r\n            Log.d(TAG, \"Transmit as Exposure Notification Beacon with id1=\" + Constants.id1);\r\n            Beacon beacon = new Beacon.Builder()\r\n                    .setId1(Constants.id1)\r\n                    .setDataFields(Arrays.asList(new Long[]{0l}))\r\n                    .build();\r\n\r\n            BeaconParser beaconParser = new BeaconParser()\r\n                    .setBeaconLayout(\"s:0-1=fd6f,p:0-0:-63,i:2-17,d:18-21\");\r\n            BeaconTransmitter beaconTransmitter = new\r\n                    BeaconTransmitter(getApplicationContext(), beaconParser);\r\n            beaconTransmitter.startAdvertising(beacon);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Callback when an Beacon enters the specified region\r\n     *\r\n     * @param region the specified region\r\n     */\r\n    @Override\r\n    public void didEnterRegion(Region region) {\r\n        Log.d(TAG, \"didEnterRegion()\");\r\n        try {\r\n            //Start the ranging process\r\n            beaconManager.startRangingBeaconsInRegion(region);\r\n        } catch (RemoteException e) {\r\n            if (BuildConfig.DEBUG) Log.d(TAG, \"Can't start ranging\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Callback when an Beacon exits the specified region\r\n     *\r\n     * @param region the specified region\r\n     */\r\n    @Override\r\n    public void didExitRegion(Region region) {\r\n        Log.d(TAG, \"didExitRegion()\");\r\n        try {\r\n            beaconManager.stopRangingBeaconsInRegion(region);\r\n        } catch (RemoteException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Callback when there is at least one beacon in the region\r\n     *\r\n     * @param state  the current state 1 = INSIDE, 0 = OUTSIDE\r\n     * @param region the specified region\r\n     */\r\n    @Override\r\n    public void didDetermineStateForRegion(int state, Region region) {\r\n        Log.d(TAG, \"didDetermineStateForRegion()\");\r\n        Log.d(TAG, \"I have just switched from seeing/not seeing beacons: \" + state);\r\n    }\r\n\r\n    /**\r\n     * Callback when the ranging from didEnterRegion(Region region): beaconManager.startRangingBeaconsInRegion(region);\r\n     * was triggered to determine data from the beacons\r\n     *\r\n     * @param beacons\r\n     * @param region\r\n     */\r\n    @Override\r\n    public void didRangeBeaconsInRegion(Collection<Beacon> beacons, Region region) {\r\n        if (beacons.size() > 0) {\r\n            for (Beacon b : beacons) {\r\n                String beaconid1 = String.valueOf(b.getId1());\r\n                if (beaconid1.substring(0, 8).equals(\"01234567\")) {\r\n                    String context = \"Beacon found: id1=\" + beaconid1;\r\n                    Log.d(TAG, context);\r\n                    //Comment out to send Notification\r\n                    //sendNotification(context);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the rangeNotifier to the beaconManager when the beaconManager is online (Callback)\r\n     */\r\n    @Override\r\n    public void onBeaconServiceConnect() {\r\n        Log.d(TAG, \"onBeaconServiceConnect()\");\r\n        beaconManager.setRangeNotifier(this);\r\n    }\r\n\r\n    /**\r\n     * Sends notification from background with given context for test purposes\r\n     *\r\n     * @param context the given context for the notification\r\n     */\r\n    private void sendNotification(String context) {\r\n        NotificationManager notificationManager =\r\n                (NotificationManager) this.getSystemService(Context.NOTIFICATION_SERVICE);\r\n        Notification.Builder builder;\r\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\r\n            NotificationChannel channel = new NotificationChannel(\"Beacon Reference Notifications\",\r\n                    \"Beacon Reference Notifications\", NotificationManager.IMPORTANCE_HIGH);\r\n            channel.enableLights(true);\r\n            channel.enableVibration(true);\r\n            channel.setLockscreenVisibility(Notification.VISIBILITY_PUBLIC);\r\n            notificationManager.createNotificationChannel(channel);\r\n            builder = new Notification.Builder(this, channel.getId());\r\n        } else {\r\n            builder = new Notification.Builder(this);\r\n            builder.setPriority(Notification.PRIORITY_HIGH);\r\n        }\r\n\r\n        TaskStackBuilder stackBuilder = TaskStackBuilder.create(this);\r\n        stackBuilder.addNextIntent(new Intent(this, MainActivity.class));\r\n        PendingIntent resultPendingIntent =\r\n                stackBuilder.getPendingIntent(\r\n                        0,\r\n                        PendingIntent.FLAG_UPDATE_CURRENT\r\n                );\r\n        builder.setSmallIcon(R.drawable.ic_launcher);\r\n        builder.setContentTitle(\"I detect a beacon\");\r\n        builder.setContentText(context);\r\n        builder.setContentIntent(resultPendingIntent);\r\n        notificationManager.notify(1, builder.build());\r\n    }\r\n\r\n    /**\r\n     * Method that returns the application context\r\n     *\r\n     * @return application context\r\n     */\r\n    public static Context getAppContext() {\r\n        return BeaconBackgroundService.context;\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/de/monokel/frontend/keytransfer/BeaconBackgroundService.java	(revision 161fcba79a7cd8a3063de4224b496b454d354ae9)
+++ app/src/main/java/de/monokel/frontend/keytransfer/BeaconBackgroundService.java	(date 1604568626614)
@@ -6,8 +6,6 @@
 import android.app.NotificationManager;
 import android.app.PendingIntent;
 import android.app.TaskStackBuilder;
-import android.bluetooth.le.AdvertiseCallback;
-import android.bluetooth.le.AdvertiseSettings;
 import android.content.Context;
 import android.content.Intent;
 import android.os.Build;
@@ -17,8 +15,6 @@
 import org.altbeacon.beacon.Beacon;
 import org.altbeacon.beacon.BeaconConsumer;
 import org.altbeacon.beacon.BeaconManager;
-import org.altbeacon.beacon.BeaconParser;
-import org.altbeacon.beacon.BeaconTransmitter;
 import org.altbeacon.beacon.BuildConfig;
 import org.altbeacon.beacon.RangeNotifier;
 import org.altbeacon.beacon.Region;
@@ -26,18 +22,15 @@
 import org.altbeacon.beacon.startup.BootstrapNotifier;
 import org.altbeacon.beacon.startup.RegionBootstrap;
 
-import java.util.Arrays;
 import java.util.Collection;
 
 import de.monokel.frontend.MainActivity;
 import de.monokel.frontend.R;
-import de.monokel.frontend.Constants;
 
 /**
  * BeaconBackgroundService that extends the Android Application so it starts when the Application is
  * first launched. From then on it will continue to scan for all BLE Beacons in the Background as a
  * foreground Service on Android 8+
- *
  * @author Nico Martin
  * @version 2020-11-02
  */
@@ -55,77 +48,56 @@
         super.onCreate();
         Log.d(TAG, "onCreate()");
         BeaconBackgroundService.context = getApplicationContext();
-
-        // Constants flag that disables scanning and transmitting so that development team doesn't
-        // have an App on their phone that constantly uses battery
-        if (Constants.SCAN_AND_TRANSMIT) {
-            beaconManager = org.altbeacon.beacon.BeaconManager.getInstanceForApplication(this);
+        beaconManager = org.altbeacon.beacon.BeaconManager.getInstanceForApplication(this);
 
-            // By default the AndroidBeaconLibrary will only find AltBeacons.  If you wish to make it
-            // find a different type of beacon, you must specify the byte layout for that beacon's
-            // advertisement with a line like below.  The example shows how to find a beacon with the
-            // same byte layout as AltBeacon but with a beaconTypeCode of 0xaabb.  To find the proper
-            // layout expression for other beacon types, do a web search for "setBeaconLayout"
-            // including the quotes.
-            beaconManager.getBeaconParsers().clear();
-            beaconManager.getBeaconParsers().add(new BeaconParser().
-                    setBeaconLayout("s:0-1=fd6f,p:-:-59,i:2-17,d:18-21"));
+        beaconManager.setDebug(true);
 
-            // Uncomment the code below to use a foreground service to scan for beacons. This unlocks
-            // the ability to continually scan for long periods of time in the background on Andorid 8+
-            // in exchange for showing an icon at the top of the screen and a always-on notification to
-            // communicate to users that your app is using resources in the background.
-            Notification.Builder builder = new Notification.Builder(this);
-            builder.setSmallIcon(R.drawable.ic_launcher);
-            builder.setContentTitle("Scanning for Beacons");
-            Intent intent = new Intent(this, MainActivity.class);
-            PendingIntent pendingIntent = PendingIntent.getActivity(
-                    this, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT
-            );
-            builder.setContentIntent(pendingIntent);
-            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
-                NotificationChannel channel = new NotificationChannel("My Notification Channel ID",
-                        "My Notification Name", NotificationManager.IMPORTANCE_DEFAULT);
-                channel.setDescription("My Notification Channel Description");
-                NotificationManager notificationManager = (NotificationManager) getSystemService(
-                        Context.NOTIFICATION_SERVICE);
-                notificationManager.createNotificationChannel(channel);
-                builder.setChannelId(channel.getId());
-            }
-            beaconManager.enableForegroundServiceScanning(builder.build(), 456);
+        // Uncomment the code below to use a foreground service to scan for beacons. This unlocks
+        // the ability to continually scan for long periods of time in the background on Andorid 8+
+        // in exchange for showing an icon at the top of the screen and a always-on notification to
+        // communicate to users that your app is using resources in the background.
+        //
+
+        Notification.Builder builder = new Notification.Builder(this);
+        builder.setSmallIcon(R.drawable.ic_launcher);
+        builder.setContentTitle("Scanning for Beacons");
+        Intent intent = new Intent(this, MainActivity.class);
+        PendingIntent pendingIntent = PendingIntent.getActivity(
+                this, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT
+        );
+        builder.setContentIntent(pendingIntent);
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+            NotificationChannel channel = new NotificationChannel("My Notification Channel ID",
+                    "My Notification Name", NotificationManager.IMPORTANCE_DEFAULT);
+            channel.setDescription("My Notification Channel Description");
+            NotificationManager notificationManager = (NotificationManager) getSystemService(
+                    Context.NOTIFICATION_SERVICE);
+            notificationManager.createNotificationChannel(channel);
+            builder.setChannelId(channel.getId());
+        }
+        beaconManager.enableForegroundServiceScanning(builder.build(), 456);
 
-            // For the above foreground scanning service to be useful, you need to disable
-            // JobScheduler-based scans (used on Android 8+) and set a fast background scan
-            // cycle that would otherwise be disallowed by the operating system.
-            beaconManager.setEnableScheduledScanJobs(false);
-            beaconManager.setBackgroundBetweenScanPeriod(Constants.BACKGROUND_SCAN_PERIOD);
-            beaconManager.setForegroundBetweenScanPeriod(Constants.FOREGROUND_SCAN_PERIOD);
-
+        // For the above foreground scanning service to be useful, you need to disable
+        // JobScheduler-based scans (used on Android 8+) and set a fast background scan
+        // cycle that would otherwise be disallowed by the operating system.
+        //
+        beaconManager.setEnableScheduledScanJobs(false);
+        beaconManager.setBackgroundBetweenScanPeriod(0);
+        beaconManager.setBackgroundScanPeriod(1100);
 
-            Log.d(TAG, "setting up background monitoring for beacons and power saving");
-            // wake up the app when a beacon is seen
-            Region region = new Region("backgroundRegion", null, null, null);
-            regionBootstrap = new RegionBootstrap(this, region);
+        Log.d(TAG, "setting up background monitoring for beacons and power saving");
+        // wake up the app when a beacon is seen
+        Region region = new Region("backgroundRegion", null, null, null);
+        regionBootstrap = new RegionBootstrap(this, region);
 
-            beaconManager.bind(this);
-            // simply constructing this class and holding a reference to it in your custom Application
-            // class will automatically cause the BeaconLibrary to save battery whenever the application
-            // is not visible.  This reduces bluetooth power usage by about 60%
-            backgroundPowerSaver = new BackgroundPowerSaver(this);
+        // simply constructing this class and holding a reference to it in your custom Application
+        // class will automatically cause the BeaconLibrary to save battery whenever the application
+        // is not visible.  This reduces bluetooth power usage by about 60%
+        backgroundPowerSaver = new BackgroundPowerSaver(this);
 
-            // This code block starts beacon transmission
-            Log.d(TAG, "Transmit as Exposure Notification Beacon with id1=" + Constants.id1);
-            Beacon beacon = new Beacon.Builder()
-                    .setId1(Constants.id1)
-                    .setDataFields(Arrays.asList(new Long[]{0l}))
-                    .build();
-
-            BeaconParser beaconParser = new BeaconParser()
-                    .setBeaconLayout("s:0-1=fd6f,p:0-0:-63,i:2-17,d:18-21");
-            BeaconTransmitter beaconTransmitter = new
-                    BeaconTransmitter(getApplicationContext(), beaconParser);
-            beaconTransmitter.startAdvertising(beacon);
-        }
+        beaconManager.setBackgroundBetweenScanPeriod(2000l);
+        beaconManager.setForegroundBetweenScanPeriod(2000l);
+        beaconManager.bind(this);
     }
 
     /**
@@ -146,7 +118,6 @@
 
     /**
      * Callback when an Beacon exits the specified region
-     *
      * @param region the specified region
      */
     @Override
@@ -174,7 +145,6 @@
     /**
      * Callback when the ranging from didEnterRegion(Region region): beaconManager.startRangingBeaconsInRegion(region);
      * was triggered to determine data from the beacons
-     *
      * @param beacons
      * @param region
      */
@@ -182,13 +152,10 @@
     public void didRangeBeaconsInRegion(Collection<Beacon> beacons, Region region) {
         if (beacons.size() > 0) {
             for (Beacon b : beacons) {
-                String beaconid1 = String.valueOf(b.getId1());
-                if (beaconid1.substring(0, 8).equals("01234567")) {
-                    String context = "Beacon found: id1=" + beaconid1;
-                    Log.d(TAG, context);
-                    //Comment out to send Notification
-                    //sendNotification(context);
-                }
+                String context = "Beacon found: id1=" + b.getId1() + ", id2=" + b.getId2() + ", id3=" + b.getId3();
+                Log.d(TAG, context);
+                //Comment out to send Notification
+                //sendNotification(context);
             }
         }
     }
@@ -204,7 +171,6 @@
 
     /**
      * Sends notification from background with given context for test purposes
-     *
      * @param context the given context for the notification
      */
     private void sendNotification(String context) {
@@ -240,7 +206,6 @@
 
     /**
      * Method that returns the application context
-     *
      * @return application context
      */
     public static Context getAppContext() {
Index: app/src/main/java/de/monokel/frontend/provider/LocalKeySafer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/de/monokel/frontend/provider/LocalKeySafer.java	(date 1604568626549)
+++ app/src/main/java/de/monokel/frontend/provider/LocalKeySafer.java	(date 1604568626549)
@@ -0,0 +1,180 @@
+package de.monokel.frontend.provider;
+
+import android.content.Context;
+
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.List;
+
+import de.monokel.frontend.keytransfer.BeaconBackgroundService;
+
+/**
+ * This Class has the purpose to safe, read and manage the keys of the contact-persons.
+ *
+ * @author Mergim Miftari
+ */
+public class LocalKeySafer {
+    /**
+     * safes the given key and the time of the method-call. If the parameter is null, the method deleteOldKeyPairs() is called.
+     *
+     * @param contactKey The Key of the contact
+     */
+    public synchronized static void addKeyPairToSavedKeyPairs(String contactKey) {
+        if (contactKey == null) {
+            deleteOldKeyPairs();
+        } else {
+            String alreadySavedKeyPairs = readKeyPairsDataFile();
+            String allKeyPairsToSafe = alreadySavedKeyPairs + "-<>-" + contactKey + "----" + new Date().toString();
+            try {
+                FileOutputStream data = BeaconBackgroundService.getAppContext().openFileOutput("cowappkeys.txt",
+                        Context.MODE_PRIVATE);
+                data.write(allKeyPairsToSafe.getBytes());
+                data.close();
+            } catch (IOException ex) {
+                System.out.println("Some Mistakes happened at addKeyPairToSavedKeyPairs(...)");
+            }
+        }
+    }
+
+    /**
+     * This method clears the keyPairDataFile.
+     */
+    public static void clearKeyPairDataFile() {
+        try {
+            String nothing = "";
+            FileOutputStream data = BeaconBackgroundService.getAppContext().openFileOutput("cowappkeys.txt",
+                    Context.MODE_PRIVATE);
+            data.write(nothing.getBytes());
+            data.close();
+        } catch (IOException ex) {
+            System.out.println("Some Mistakes happened at clearKeyPairDataFile()");
+        }
+    }
+
+    /**
+     * Reads the cowappkey.txt datafile and returns it as String.
+     * If there is no cowappkeys.txt datafile the return-value is an empty String.
+     *
+     * @return returns the cowappkeys.txt data file as String or an empty String
+     */
+    public static String readKeyPairsDataFile() {
+        try {
+            FileInputStream datafile = BeaconBackgroundService.getAppContext().openFileInput("cowappkeys.txt");
+            List<Byte> data = new ArrayList<Byte>();
+
+            while (true) {
+                int b = datafile.read();
+                if (b == -1) {
+                    break; // end of the datafile.
+                } else {
+                    data.add((byte) b);
+                }
+            }
+            // Bytes to words
+            byte[] bytes = new byte[data.size()];
+
+            for (int i = 0; i < bytes.length; i++) {
+                bytes[i] = data.get(i);
+            }
+
+            String text = new String(bytes);
+            return text;
+        } catch (Exception ex) { //datafile not found
+            return "";
+        }
+    }
+
+    /**
+     * This Method returns an Array of Strings.
+     * The format of the Strings is the following:
+     * contactKey + "----" + new Date().toString()
+     *
+     * @return A list of Strings. If there are no saved keys, the return-value is null.
+     */
+    public static String[] getKeyPairs() {
+        String keyPairs = readKeyPairsDataFile();
+        if (keyPairs.equals("")) {
+            return null;
+        }
+        keyPairs = keyPairs.substring(4);
+        return keyPairs.split("-<>-");
+    }
+
+    /**
+     * All Keys older than 3 weeks are going to be deleted.
+     */
+    public static void deleteOldKeyPairs() {
+        String[] keyPairs = getKeyPairs();
+        String result = "";
+
+        if (keyPairs != null) {
+            for (String string : keyPairs) {
+                String[] strings = string.split("----");
+                Date dateOfKey = new Date(strings[1]);
+                if (!dateIsOld(dateOfKey)) {
+                    result = result + "-<>-" + string;
+                }
+            }
+
+            try {
+                FileOutputStream data = BeaconBackgroundService.getAppContext().openFileOutput("cowappkeys.txt",
+                        Context.MODE_PRIVATE);
+                data.write(result.getBytes());
+                data.close();
+            } catch (IOException ex) {
+                System.out.println("Some Mistakes happened at deleteOldKeyPairs(...)");
+            }
+        }
+    }
+
+    /**
+     * Returns true if the date is older than 3 weeks.
+     *
+     * @param date
+     * @return
+     */
+    private static boolean dateIsOld(Date date) {
+        boolean result = false;
+        Date currentDate = new Date();
+
+        int currentMonth = currentDate.getMonth();
+        int currentDay = currentDate.getDay();
+        int oldMonth = date.getMonth();
+        int oldDay = date.getDay();
+
+        if (currentMonth != oldMonth) {
+            int days = 0;
+
+            switch (oldMonth) {
+                case 1:
+                case 7:
+                case 3:
+                case 5:
+                case 8:
+                case 10:
+                case 12:
+                    days = 31;
+                    break;
+
+                case 4:
+                case 6:
+                case 9:
+                case 11:
+                    days = 30;
+                    break;
+
+                case 2:
+                    days = 28;
+                    break;
+            }
+
+            if (((days - oldDay) + currentDay) > 21) {
+                result = true;
+            }
+        }
+        return result;
+    }
+}
Index: app/src/main/java/de/monokel/frontend/risklevel/RiskLevel.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/de/monokel/frontend/risklevel/RiskLevel.java	(date 1604568626563)
+++ app/src/main/java/de/monokel/frontend/risklevel/RiskLevel.java	(date 1604568626563)
@@ -0,0 +1,148 @@
+package de.monokel.frontend.risklevel;
+
+
+import java.util.Collections;
+import java.util.SortedSet;
+import java.util.TreeSet;
+
+import de.monokel.frontend.provider.LocalRiskLevelSafer;
+
+/**
+ * Klasse mit allen Operationen welche das Risikolevel betreffen.
+ * Das Risikolevel ist ein Wert zwischen 0 und 100.
+ * Er soll immer jeden Tag aktualisiert werden, oder wenn eine Infektionsmeldung durchgeführt wurde
+ *
+ * @author jonas
+ * @date 26.10.2020
+ */
+
+
+public class RiskLevel {
+
+    /**
+     * Methode zur Aktualisierung des Risikolevels.
+     *
+     * @param newRiskLevel  ist das neue Risikolevel, sollte übergeben werden durch die Methode calculateRiskLevel.
+     * @param isDailyUpdate (true/1:) Gibt an ob es sich um die tägliche Aktualisierung handelt, oder um den anderen Fall,(false/0:) dass es sich um eine Aktualisierung aufgrund einer Infektionsmeldung handelt.
+     */
+    public static void updateRiskLevel(int newRiskLevel, boolean isDailyUpdate) {
+
+        checkDaysSinceLastContact();
+
+        if (newRiskLevel < 0 || newRiskLevel > 100) {
+            throw new IllegalArgumentException("Illegal Risk Level: must be an int value between 0 and 100!");
+
+        } else if (LocalRiskLevelSafer.getRiskLevel() > newRiskLevel || isDailyUpdate) {
+
+            increaseDaysSinceLastContact();
+
+        } else if (LocalRiskLevelSafer.getRiskLevel() > newRiskLevel || !isDailyUpdate) {
+
+        } else if (LocalRiskLevelSafer.getRiskLevel() < newRiskLevel || isDailyUpdate) {
+            setRiskLevel(newRiskLevel);
+            resetDaysSinceLastContact();
+
+
+        } else if (LocalRiskLevelSafer.getRiskLevel() < newRiskLevel || !isDailyUpdate) {
+            setRiskLevel(newRiskLevel);
+            resetDaysSinceLastContact();
+        }
+    }
+
+    /**
+     * gleiche Methode wie die daurauffolgende, nur ohne den 2. Parameter, da dieser hier nicht berücksichtig werden muss.
+     *
+     * @param action Aktion welche beim berechnen des Risikolevels berücktsichtigt werden soll, hier wird jedoch nur ein NO_CONTACT berücktsicht, für alle anderen Fälle muss die darauffolgende Methode verwendet werden!(Diese hat einen weiteren Enum Parameter)
+     */
+
+    public static int calculateRiskLevel(TypeOfExposureEnum action) {
+        if (action == TypeOfExposureEnum.NO_CONTACT) {
+
+            checkDaysSinceLastContact();
+        }
+        return 0;
+    }
+
+    /**
+     * Methode zum berechnen des Risikolevels anhand der übergebenen Aktion
+     *
+     * @param action Art der Aktion welche eine Infektion zur Folge haben könnte
+     * @param amount Anzahl wie oft die zuvor genannte Aktion stattgefunden, z.B.: es wurden 1-wenige Schlüssel ausgetauscht, es wurden wenige - einige Schlüssel ausgetauscht oder eben einige bis viele Schlüssel ausgetauscht.
+     * @return berechneter Wert des Risikolevels
+     */
+
+
+    public int calculateRiskLevel(TypeOfExposureEnum action, AmountOfContactsEnum amount) {
+
+        int localRiskLevel = 101;
+
+        if (action == TypeOfExposureEnum.SHORT_EXPOSURE_INDIRECT_CONTACT || amount == AmountOfContactsEnum.FEW) {
+            localRiskLevel = 20;
+
+        } else if (action == TypeOfExposureEnum.SHORT_EXPOSURE_INDIRECT_CONTACT || amount == AmountOfContactsEnum.SOME) {
+            localRiskLevel = 30;
+        } else if (action == TypeOfExposureEnum.SHORT_EXPOSURE_INDIRECT_CONTACT || amount == AmountOfContactsEnum.MANY) {
+            localRiskLevel = 35;
+
+
+        } else if (action == TypeOfExposureEnum.LONG_EXPOSURE_INDIRECT_CONTACT || amount == AmountOfContactsEnum.FEW) {
+            localRiskLevel = 40;
+        } else if (action == TypeOfExposureEnum.LONG_EXPOSURE_INDIRECT_CONTACT || amount == AmountOfContactsEnum.SOME) {
+            localRiskLevel = 50;
+        } else if (action == TypeOfExposureEnum.LONG_EXPOSURE_INDIRECT_CONTACT || amount == AmountOfContactsEnum.SOME) {
+            localRiskLevel = 60;
+
+
+        } else if (action == TypeOfExposureEnum.SHORT_EXPOSURE_DIRECT_CONTACT || amount == AmountOfContactsEnum.FEW) {
+            localRiskLevel = 90;
+        } else if (action == TypeOfExposureEnum.SHORT_EXPOSURE_DIRECT_CONTACT || amount == AmountOfContactsEnum.SOME) {
+            localRiskLevel = 95;
+        } else if (action == TypeOfExposureEnum.SHORT_EXPOSURE_DIRECT_CONTACT || amount == AmountOfContactsEnum.MANY) {
+            localRiskLevel = 97;
+
+
+        } else if (action == TypeOfExposureEnum.LONG_EXPOSURE_DIRECT_CONTACT || amount == AmountOfContactsEnum.FEW) {
+            localRiskLevel = 96;
+        } else if (action == TypeOfExposureEnum.LONG_EXPOSURE_DIRECT_CONTACT || amount == AmountOfContactsEnum.SOME) {
+            localRiskLevel = 98;
+        } else if (action == TypeOfExposureEnum.LONG_EXPOSURE_DIRECT_CONTACT || amount == AmountOfContactsEnum.MANY) {
+            localRiskLevel = 100;
+        }
+
+        return localRiskLevel;
+
+    }
+
+    public static void setRiskLevel(int newRiskLevel) {
+        LocalRiskLevelSafer.safeRiskLevel(newRiskLevel);
+
+    }
+
+    public static void setDaysSinceLastUpdate(int newDaysSinceLastUpdate) {
+        LocalRiskLevelSafer.safeDaysSinceLastContact(newDaysSinceLastUpdate);
+    }
+
+    public static void increaseDaysSinceLastContact() {
+        int i = LocalRiskLevelSafer.getDaysSinceLastContact();
+        i = i + 1;
+        LocalRiskLevelSafer.safeDaysSinceLastContact(i);
+    }
+
+
+    public static void resetDaysSinceLastContact() {
+        LocalRiskLevelSafer.safeDaysSinceLastContact(0);
+    }
+
+    public static void checkDaysSinceLastContact() {
+        int daysSinceLastUpdate = LocalRiskLevelSafer.getDaysSinceLastContact();
+
+        if (daysSinceLastUpdate > 14) {
+            LocalRiskLevelSafer.safeRiskLevel(0);
+
+        }
+    }
+
+}
+
+
+
Index: app/src/main/java/de/monokel/frontend/risklevel/AmountOfContactsEnum.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/de/monokel/frontend/risklevel/AmountOfContactsEnum.java	(date 1604568626542)
+++ app/src/main/java/de/monokel/frontend/risklevel/AmountOfContactsEnum.java	(date 1604568626542)
@@ -0,0 +1,11 @@
+package de.monokel.frontend.risklevel;
+
+/**
+ * Einfaches Enum zur Klassifizierung wie oft etwas stattgefunden hat:
+ * <p>
+ * FEW: 1 bis wenige Fälle
+ * SOME: wenige bis einige Fälle
+ * MANY: einige bis viele Fälle
+ */
+
+public enum AmountOfContactsEnum {FEW, SOME, MANY}
Index: app/src/main/java/de/monokel/frontend/provider/LocalNotificationSafer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/de/monokel/frontend/provider/LocalNotificationSafer.java	(date 1604568626533)
+++ app/src/main/java/de/monokel/frontend/provider/LocalNotificationSafer.java	(date 1604568626533)
@@ -0,0 +1,180 @@
+package de.monokel.frontend.provider;
+
+import android.content.Context;
+
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.List;
+
+import de.monokel.frontend.keytransfer.BeaconBackgroundService;
+
+/**
+ * This Class has the purpose to safe, read and manage the Notifications of the user.
+ *
+ * @author Mergim Miftari
+ */
+public class LocalNotificationSafer {
+    /**
+     * safes the given notification and the time of the method-call. If the parameter is null, the method deleteOldNotifications() is called.
+     *
+     * @param notification The new notification as String
+     */
+    public synchronized static void addNotificationToSavedNotifications(String notification) {
+        if (notification == null) {
+            deleteOldNotifications();
+        } else {
+            String alreadySavedNotifications = readNotificationDataFile();
+            String allNotificationsToSafe = alreadySavedNotifications + "-<>-" + notification + "----" + new Date().toString();
+            try {
+                FileOutputStream data = BeaconBackgroundService.getAppContext().openFileOutput("cowappnotifications.txt",
+                        Context.MODE_PRIVATE);
+                data.write(allNotificationsToSafe.getBytes());
+                data.close();
+            } catch (IOException ex) {
+                System.out.println("Some Mistakes happened at addNotificationToSavedNotifications");
+            }
+        }
+    }
+
+    /**
+     * This method clears the Notifications-Datafile.
+     */
+    public static void clearNotificationDataFile() {
+        try {
+            String nothing = "";
+            FileOutputStream data = BeaconBackgroundService.getAppContext().openFileOutput("cowappnotifications.txt",
+                    Context.MODE_PRIVATE);
+            data.write(nothing.getBytes());
+            data.close();
+        } catch (IOException ex) {
+            System.out.println("Some Mistakes happened at clearNotificationsDataFile()");
+        }
+    }
+
+    /**
+     * Reads the "cowappnotifications.txt" datafile and returns it as String.
+     * If there is no "cowappnotifications.txt" datafile the return-value is an empty String.
+     *
+     * @return returns the "cowappnotifications.txt" data file as String or an empty String
+     */
+    public static String readNotificationDataFile() {
+        try {
+            FileInputStream datafile = BeaconBackgroundService.getAppContext().openFileInput("cowappnotifications.txt");
+            List<Byte> data = new ArrayList<Byte>();
+
+            while (true) {
+                int b = datafile.read();
+                if (b == -1) {
+                    break; // end of the datafile.
+                } else {
+                    data.add((byte) b);
+                }
+            }
+            // Bytes to words
+            byte[] bytes = new byte[data.size()];
+
+            for (int i = 0; i < bytes.length; i++) {
+                bytes[i] = data.get(i);
+            }
+
+            String text = new String(bytes);
+            return text;
+        } catch (Exception ex) { //datafile not found
+            return "";
+        }
+    }
+
+    /**
+     * This Method returns an Array of Strings.
+     * The format of the Strings is the following:
+     * Notification + "----" + new Date().toString()
+     *
+     * @return A list of Strings. If there are no saved notifications, the return-value is null.
+     */
+    public static String[] getNotifications() {
+        String notifications = readNotificationDataFile();
+        if (notifications.equals("")) {
+            return null;
+        }
+        notifications = notifications.substring(4);
+        return notifications.split("-<>-");
+    }
+
+    /**
+     * All Notifications older than 3 weeks are going to be deleted.
+     */
+    public static void deleteOldNotifications() {
+        String[] notifications = getNotifications();
+        String result = "";
+
+        if (notifications != null) {
+            for (String string : notifications) {
+                String[] strings = string.split("----");
+                Date dateOfNotification = new Date(strings[1]);
+                if (!dateIsOld(dateOfNotification)) {
+                    result = result + "-<>-" + string;
+                }
+            }
+
+            try {
+                FileOutputStream data = BeaconBackgroundService.getAppContext().openFileOutput("cowappnotifications.txt",
+                        Context.MODE_PRIVATE);
+                data.write(result.getBytes());
+                data.close();
+            } catch (IOException ex) {
+                System.out.println("Some Mistakes happened at deleteOldNotifications(...)");
+            }
+        }
+    }
+
+    /**
+     * Returns true if the date is older than 3 weeks.
+     *
+     * @param date
+     * @return
+     */
+    private static boolean dateIsOld(Date date) {
+        boolean result = false;
+        Date currentDate = new Date();
+
+        int currentMonth = currentDate.getMonth();
+        int currentDay = currentDate.getDay();
+        int oldMonth = date.getMonth();
+        int oldDay = date.getDay();
+
+        if (currentMonth != oldMonth) {
+            int days = 0;
+
+            switch (oldMonth) {
+                case 1:
+                case 7:
+                case 3:
+                case 5:
+                case 8:
+                case 10:
+                case 12:
+                    days = 31;
+                    break;
+
+                case 4:
+                case 6:
+                case 9:
+                case 11:
+                    days = 30;
+                    break;
+
+                case 2:
+                    days = 28;
+                    break;
+            }
+
+            if (((days - oldDay) + currentDay) > 21) {
+                result = true;
+            }
+        }
+        return result;
+    }
+}
Index: app/src/main/res/values/strings.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><resources>\r\n    <string name=\"app_name\">CoWApp</string>\r\n    <string name=\"channel_name\">NotificationChannel</string>\r\n    <string name=\"channel_description\">This channel is for push notifications to inform about possible health risk</string>\r\n</resources>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/res/values/strings.xml	(revision 161fcba79a7cd8a3063de4224b496b454d354ae9)
+++ app/src/main/res/values/strings.xml	(date 1604568626654)
@@ -1,5 +1,6 @@
 <resources>
-    <string name="app_name">CoWApp</string>
+    <string name="app_name">frontend</string>
     <string name="channel_name">NotificationChannel</string>
     <string name="channel_description">This channel is for push notifications to inform about possible health risk</string>
+    <string name="daysSinceText">Sie Helfen test</string>
 </resources>
\ No newline at end of file
