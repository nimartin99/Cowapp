Index: app/src/main/java/de/hhn/frontend/provider/LocalSafer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package de.hhn.frontend.provider;\r\n\r\nimport android.content.Context;\r\nimport android.util.Log;\r\n\r\nimport androidx.annotation.StringRes;\r\n\r\nimport java.io.FileInputStream;\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.io.ObjectInputStream;\r\nimport java.io.ObjectOutputStream;\r\nimport java.util.ArrayList;\r\nimport java.util.Date;\r\nimport java.util.HashMap;\r\nimport java.util.HashSet;\r\nimport java.util.List;\r\n\r\nimport de.hhn.frontend.Constants;\r\nimport de.hhn.frontend.DebugLog;\r\nimport de.hhn.frontend.R;\r\nimport de.hhn.frontend.keytransfer.BeaconBackgroundService;\r\nimport de.hhn.frontend.risklevel.DirectContact;\r\nimport de.hhn.frontend.risklevel.IndirectContact;\r\n\r\n/**\r\n * This is the class for persistent saving of data at the client-side.\r\n *\r\n * @author Miftari\r\n * @version Nov 2020\r\n */\r\npublic class LocalSafer {\r\n    private static final String TAG = \"LocalSafer\";\r\n\r\n    private static final String DATAFILE01 = \"cowappkeys.txt\";\r\n    private static final String DATAFILE02 = \"cowappnotifications.txt\";\r\n    private static final String DATAFILE03 = \"cowapprisklevel.txt\";\r\n    private static final String DATAFILE04 = \"cowappdaysslc.txt\";\r\n    private static final String DATAFILE05 = \"cowappfirstdate.txt\";\r\n    private static final String DATAFILE06 = \"cowappownkey.txt\";\r\n    private static final String DATAFILE07 = \"cowappownkeys.txt\";\r\n    private static final String DATAFILE08 = \"cowappindirectcontacts.txt\";\r\n    private static final String DATAFILE09 = \"cowappkeybuffer.txt\";\r\n    private static final String DATAFILE10 = \"cowappdirectcontacts.txt\";\r\n    private static final String DATAFILE11 = \"cowappnotificationcount.txt\";\r\n    private static final String DATAFILE12 = \"cowappdebuglogger.txt\";\r\n    private static final String DATAFILE13 = \"cowappalisalarmringlogged.txt\";\r\n    private static final String DATAFILE14 = \"cowappisalarmsetlogged.txt\";\r\n    private static final String DATAFILE15 = \"cowappniskeytransmitlogged.txt\";\r\n    private static final String DATAFILE16 = \"cowappiskeysafelogged.txt\";\r\n    private static final String DATAFILE17 = \"cowappisfirstappstart\";\r\n    private static final String DATAFILE21 = \"cowappindirectcontacts.txt\";\r\n    private static final String DATAFILE22 = \"cowappdirectcontacts.txt\";\r\n    private static final String DATAFILE23 = \"cowappdateolri\";\r\n    /**\r\n     * This methods saves a String under a datafileName.\r\n     * If there is not such datafile, it will be created, when you call this methode.\r\n     *\r\n     * @param datafile The Name of the datafile.\r\n     * @param value    The String.\r\n     */\r\n    public static void safeStringAtDatafile(String datafile, String value, Context context) {\r\n        Log.d(TAG, \"safeStringAtDatafile -> String: \" + value + \" at data file: \" + datafile);\r\n        try {\r\n            FileOutputStream data;\r\n            if (context == null) {\r\n                data = BeaconBackgroundService.getAppContext().openFileOutput(datafile, Context.MODE_PRIVATE);\r\n            } else {\r\n                data = context.openFileOutput(datafile, Context.MODE_PRIVATE);\r\n            }\r\n            data.write(value.getBytes());\r\n            data.close();\r\n        } catch (IOException ex) {\r\n            System.out.println(\"Some Mistakes happened at safeStringAtDatafile(...)\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the value of a Datafile. If there is no such datafile, the returnvalue is an empty string.\r\n     *\r\n     * @param datafileName the name of the datafile.\r\n     * @return the value of the datafile.\r\n     */\r\n    private static String readDataFile(String datafileName, Context context) {\r\n        Log.d(TAG, \"readDataFile: \" + datafileName);\r\n        try {\r\n            FileInputStream datafile;\r\n            if (context == null) {\r\n                datafile = BeaconBackgroundService.getAppContext().openFileInput(datafileName);\r\n            } else {\r\n                datafile = context.openFileInput(datafileName);\r\n            }\r\n            List<Byte> data = new ArrayList<Byte>();\r\n\r\n            while (true) {\r\n                int b = datafile.read();\r\n                if (b == -1) {\r\n                    break; // end of the datafile.\r\n                } else {\r\n                    data.add((byte) b);\r\n                }\r\n            }\r\n            // Bytes to words\r\n            byte[] bytes = new byte[data.size()];\r\n\r\n            for (int i = 0; i < bytes.length; i++) {\r\n                bytes[i] = data.get(i);\r\n            }\r\n\r\n            String text = new String(bytes);\r\n            return text;\r\n        } catch (Exception ex) { //datafile not found\r\n            return \"\";\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns true if the date is older than 2 weeks.\r\n     *\r\n     * @param date\r\n     * @return\r\n     */\r\n    private static boolean dateIsOld(Date date) {\r\n        Log.d(TAG, \"dateIsOld() was called\");\r\n\r\n        boolean result = false;\r\n        Date oldDate = date;\r\n        oldDate.setDate(date.getDate() + 14);\r\n\r\n        if (oldDate.before(new Date())) {\r\n            result = true;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * This Method returns an Array of Strings.\r\n     * The format of the Strings is the following:\r\n     * value + \"----\" + new Date().toString()\r\n     *\r\n     * @return A list of Strings. If there are no saved keys, the return-value is null.\r\n     */\r\n    private static String[] getValuesAsArray(String datafileName, Context context) {\r\n        Log.d(TAG, \"getValuesAsArray() was called with datafile: \" + datafileName);\r\n        String values = readDataFile(datafileName, null);\r\n\r\n        if (values.equals(\"\")) {\r\n            return null;\r\n        }\r\n        values = values.substring(4);\r\n        return values.split(\"-<>-\");\r\n    }\r\n\r\n    /**\r\n     * All Values older than 2 weeks are going to be deleted.\r\n     */\r\n    private static void deleteOldValues(String datafileName, Context context) {\r\n        Log.d(TAG, \"deleteOldValues was called with datafile \" + datafileName);\r\n\r\n        String[] values = getValuesAsArray(datafileName, context);\r\n        String result = \"\";\r\n\r\n        if (values != null) {\r\n            for (String string : values) {\r\n                String[] strings = string.split(\"----\");\r\n                Date dateOfValue = new Date(strings[1]);\r\n                if (!dateIsOld(dateOfValue)) {\r\n                    result = result + \"-<>-\" + string;\r\n                }\r\n            }\r\n\r\n            safeStringAtDatafile(datafileName, result, context);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * safes the given key and the time of the method-call. If the parameter is null, the method deleteOldKeyPairs() is called.\r\n     *\r\n     * @param contactKey The Key of the contact\r\n     */\r\n    public synchronized static void addKeyPairToSavedKeyPairs(String contactKey, Context context) {\r\n        Log.d(TAG, \"addKeyPairToSavedKeyPairs: \" + contactKey);\r\n        if (contactKey == null) {\r\n            deleteOldValues(DATAFILE01, context);\r\n        } else {\r\n            String alreadySavedKeyPairs = readDataFile(DATAFILE01, context);\r\n            String allKeyPairsToSafe = alreadySavedKeyPairs + \"-<>-\" + contactKey.substring(9) + \"----\" + new Date().toString();\r\n            safeStringAtDatafile(DATAFILE01, allKeyPairsToSafe, context);\r\n\r\n            if (Constants.DEBUG_MODE && isKeySafeLogged(context)) {\r\n                addLogValueToDebugLog(BeaconBackgroundService.getAppContext().getString(R.string.key_was_saved) + contactKey, context);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This method clears the keyPairDataFile.\r\n     */\r\n    public static void clearKeyPairDataFile(Context context) {\r\n        Log.d(TAG, \"cleareKeyPairDataFile() was called.\");\r\n        safeStringAtDatafile(DATAFILE01, \"\", context);\r\n    }\r\n\r\n    /**\r\n     * safes the given key.\r\n     * @param contactKey The Key of the contact\r\n     */\r\n    public synchronized static String[] addKeyToBufferFile(String contactKey, Context context) {\r\n        Log.d(TAG, \"addKeyToBufferFile: \" + contactKey);\r\n\r\n        if (contactKey == null) {\r\n            String[] result = getValuesAsArray(DATAFILE09, context);\r\n            clearBufferFile(context);\r\n            return result;\r\n        } else {\r\n            String alreadySavedKeyPairs = readDataFile(DATAFILE09, context);\r\n            String allKeyPairsToSafe = alreadySavedKeyPairs + \"-<>-\" + contactKey;\r\n            safeStringAtDatafile(DATAFILE09, allKeyPairsToSafe, context);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This method clears the bufferFile.\r\n     */\r\n    public static void clearBufferFile(Context context) {\r\n        Log.d(TAG, \"cleareBufferFile() was called.\");\r\n        safeStringAtDatafile(DATAFILE09, \"\", context);\r\n    }\r\n\r\n    /**\r\n     * This Method returns an Array of Strings.\r\n     * The format of the Strings is the following:\r\n     * contactKey + \"----\" + new Date().toString()\r\n     *\r\n     * @return A list of Strings. If there are no saved keys, the return-value is null.\r\n     */\r\n    public static String[] getKeyPairs(Context context) {\r\n        Log.d(TAG, \"getKeyPairs() was called.\");\r\n        String[] result = getValuesAsArray(DATAFILE01, context);\r\n        if (result != null) {\r\n            return result;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * safes the given notification and the time of the method-call. If the parameter is null, the method deleteOldNotifications() is called.\r\n     *\r\n     * @param notification The new notification as String\r\n     */\r\n    public synchronized static void addNotificationToSavedNotifications(String notification, Context context) {\r\n        Log.d(TAG, \"addNotificationToSavedNotifications() was called with notification: \" + notification);\r\n        if (notification == null) {\r\n            deleteOldValues(DATAFILE02, context);\r\n        } else {\r\n            String alreadySavedNotifications = readDataFile(DATAFILE02, context);\r\n            String allNotificationsToSafe = alreadySavedNotifications + \"-<>-\" + notification + \"----\" + new Date().toString();\r\n\r\n            safeStringAtDatafile(DATAFILE02, allNotificationsToSafe, context);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This method clears the Notifications-Datafile.\r\n     */\r\n    public static void clearNotificationDataFile(Context context) {\r\n        Log.d(TAG, \"clearNotificationDataFile() was called.\");\r\n        safeStringAtDatafile(DATAFILE02, \"\", context);\r\n    }\r\n\r\n    /**\r\n     * This Method returns an Array of Strings (the notifications).\r\n     * The format of the Strings is the following:\r\n     * Notification + \"----\" + new Date().toString()\r\n     *\r\n     * @return A list of Strings. If there are no saved notifications, the return-value is null.\r\n     */\r\n    public static String[] getNotifications(Context context) {\r\n        Log.d(TAG, \"getNotifications was called.\");\r\n        return getValuesAsArray(DATAFILE02, context);\r\n    }\r\n\r\n    /**\r\n     * Safes the risk Level.\r\n     *\r\n     * @param riskLevel risk level as int\r\n     */\r\n    public static void safeRiskLevel(int riskLevel, Context context) {\r\n        Log.d(TAG, \"safeRiskLevel() with riskLevel: \" + riskLevel);\r\n        safeStringAtDatafile(DATAFILE03, String.valueOf(riskLevel), context);\r\n    }\r\n\r\n    /**\r\n     * Getter for the risk level.\r\n     *\r\n     * @return risk level as int.\r\n     */\r\n    public static int getRiskLevel(Context context) {\r\n        Log.d(TAG, \"getRiskLevel() was called.\");\r\n        try {\r\n            return Integer.valueOf(readDataFile(DATAFILE03, context));\r\n        } catch (Exception ex) { //datafile not found\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Safes the daysSinceLastContact.\r\n     *\r\n     * @param daysSinceLastContact days Since last contact as int.\r\n     */\r\n    public static void safeDaysSinceLastContact(int daysSinceLastContact, Context context) {\r\n        Log.d(TAG, \"safeDaysSinceLastContact was called with: \" + daysSinceLastContact);\r\n        safeStringAtDatafile(DATAFILE04, String.valueOf(daysSinceLastContact), context);\r\n    }\r\n\r\n    /**\r\n     * Getter for the daysSinceLastContact.\r\n     *\r\n     * @return the days since last Contact as int.\r\n     */\r\n    public static int getDaysSinceLastContact(Context context) {\r\n        Log.d(TAG, \"getDaysSinceLastContact()\");\r\n        try {\r\n            return Integer.valueOf(readDataFile(DATAFILE04, context));\r\n        } catch (Exception ex) { //datafile not found\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Safes the date of the first start.\r\n     *\r\n     * @param date days Since last contact as int.\r\n     */\r\n    public static void safeFirstStartDate(String date, Context context) {\r\n        Log.d(TAG, \"safeFirstStartDate() was called with \" + date);\r\n        safeStringAtDatafile(DATAFILE05, date, context);\r\n    }\r\n\r\n    /**\r\n     * Getter for the date of the first start.\r\n     *\r\n     * @return the days since last Contact as int.\r\n     */\r\n    public static String getFirstStartDate(Context context) {\r\n        Log.d(TAG, \"getFirstStartDate() was called.\");\r\n        return readDataFile(DATAFILE05, context);\r\n    }\r\n\r\n    /**\r\n     * Safes the own key\r\n     *\r\n     * @param key the own key as String\r\n     */\r\n    public static void safeOwnKey(String key, Context context) {\r\n        Log.d(TAG, \"safeOwnKey was called with: \" + key);\r\n        safeStringAtDatafile(DATAFILE06, key, context);\r\n        addKeyToOwnKeys(key, context);\r\n    }\r\n\r\n\r\n    /**\r\n     * Getter for the own key\r\n     *\r\n     * @return the own key as String\r\n     */\r\n    public static String getOwnKey(Context context) {\r\n        Log.d(TAG, \"getOwnKey was called\");\r\n        String key = readDataFile(DATAFILE06, context);\r\n        if (!key.isEmpty()) {\r\n            String result = Constants.cowappBeaconIdentifier + \"-\" + readDataFile(DATAFILE06, context);\r\n            return result;\r\n        } else {\r\n            return \"\";\r\n        }\r\n    }\r\n\r\n    /**\r\n     * safes the given key and the time of the method-call. If the parameter is null, the method deleteOldKeyPairs() is called.\r\n     *\r\n     * @param ownKey The Key of the contact\r\n     */\r\n    public synchronized static void addKeyToOwnKeys(String ownKey, Context context) {\r\n        Log.d(TAG, \"addKeyToOwnKeys was called with \" + ownKey);\r\n        if (ownKey == null) {\r\n            deleteOldValues(DATAFILE07, context);\r\n        } else {\r\n            String alreadySavedKeys = readDataFile(DATAFILE07, context);\r\n            String allKeysToSafe = alreadySavedKeys + \"-<>-\" + ownKey + \"----\" + new Date().toString();\r\n            safeStringAtDatafile(DATAFILE07, allKeysToSafe, context);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This method clears the ownKeyPairDataFile.\r\n     */\r\n    public static void clearOwnKeyPairDataFile(Context context) {\r\n        Log.d(TAG, \"clearOwnKeyPairDataFile() was called.\");\r\n        safeStringAtDatafile(DATAFILE07, \"\", context);\r\n    }\r\n\r\n    /**\r\n     * This Method returns an Array of the own Strings.\r\n     * Attention: The first eight characters are the identifier of our application.\r\n     * To reduce the length of the string, the identifier are left out of the keys in this methode.\r\n     *\r\n     * @return A list of the own Strings without the first eight characters. If there are no saved keys, the return-value is null.\r\n     */\r\n    public static String[] getOwnKeys(Context context) {\r\n        Log.d(TAG, \"getOwnKeys() was called \");\r\n        String[] result = getValuesAsArray(DATAFILE07, context);\r\n        if (result != null) {\r\n            return result;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This method adds the received Key to an buffer-datafile, so we can work with it.\r\n     *\r\n     * @param key the received key\r\n     */\r\n    public synchronized static void addReceivedKey(String key, Context context) {\r\n        Log.d(TAG, \"addReceivedKey() was called \" + key);\r\n        addKeyToBufferFile(key, context);\r\n    }\r\n\r\n    /**\r\n     * This method analyzes the buffer file and adds every key just one time to the key-pari datafile.\r\n     */\r\n    public synchronized static void analyzeBufferFile(Context context) {\r\n        Log.d(TAG, \"analyzeBufferFile() was called \");\r\n\r\n        String[] bufferValues = addKeyToBufferFile(null, context);\r\n        HashSet<String> strings = new HashSet<>();\r\n\r\n        if (bufferValues != null) {\r\n            for (String string : bufferValues) {\r\n                strings.add(string);\r\n            }\r\n\r\n            for (String string : strings) {\r\n                int factor = 0;\r\n\r\n                for (String value : bufferValues) {\r\n                    if (string.equals(value)) {\r\n                        factor++;\r\n                    }\r\n                }\r\n\r\n                factor = (factor / 20);\r\n                if (factor == 0) { factor = 1; }\r\n\r\n                for (int i = 0; i != factor; i++) {\r\n                    addKeyPairToSavedKeyPairs(string, context);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public synchronized static void safeIndirectContacts(String[] indirectContacts, Context context) {\r\n        if (indirectContacts == null) {\r\n            safeStringAtDatafile(DATAFILE08, \"\", context);\r\n        } else {\r\n            String value = \"-<>-\";\r\n            for (String string: indirectContacts) {\r\n                value = value + string + \"-<>-\";\r\n            }\r\n            safeStringAtDatafile(DATAFILE08, value, context);\r\n        }\r\n    }\r\n    public synchronized static void safeDirectContacts(String[] directContacts, Context context) {\r\n        if (directContacts == null) {\r\n            safeStringAtDatafile(DATAFILE10, \"\", context);\r\n        } else {\r\n            String value = \"-<>-\";\r\n            for (String string: directContacts) {\r\n                value = value + string + \"-<>-\";\r\n            }\r\n            safeStringAtDatafile(DATAFILE10, value, context);\r\n        }\r\n    }\r\n\r\n    public synchronized static String[] getIndirectContacts(Context context) {\r\n        return getValuesAsArray(DATAFILE08, context);\r\n    }\r\n\r\n    public synchronized static String[] getdirectContacts(Context context) {\r\n        return getValuesAsArray(DATAFILE10, context);\r\n    }\r\n\r\n    /**\r\n     * Setter for the notificationCount\r\n     *\r\n     * @param notificationCount notificationCount as int\r\n     */\r\n    public static void safeNotificationCounter(int notificationCount, Context context) {\r\n        Log.d(TAG, \"safeNotificationCounter was called with: \" + notificationCount);\r\n        safeStringAtDatafile(DATAFILE11, String.valueOf(notificationCount), context);\r\n    }\r\n\r\n    /**\r\n     * Getter for the NotificationCounter.\r\n     *\r\n     * @return the NotificationCounter as int.\r\n     */\r\n    public static int getNotificationCounter(Context context) {\r\n        Log.d(TAG, \"getNotificationCount()\");\r\n        try {\r\n            return Integer.valueOf(readDataFile(DATAFILE11, context));\r\n        } catch (Exception ex) { //datafile not found\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * safes the given LogValue and the time of the method-call. If the parameter is null, the method deleteOldNotifications() is called.\r\n     *\r\n     * @param logValue The new logValue as String\r\n     */\r\n    public synchronized static void addLogValueToDebugLog(String logValue, Context context) {\r\n        Log.d(TAG, \"addLogValueToDebugLog() was called with LogValue: \" + logValue);\r\n        if (logValue == null) {\r\n            deleteOldValues(DATAFILE12, context);\r\n            DebugLog.renewTheLog();\r\n        } else {\r\n            String alreadySavedlogValues = readDataFile(DATAFILE12, context);\r\n            String alllogValueToSafe = alreadySavedlogValues + \"-<>-\" + logValue + \"----\" + new Date().toString();\r\n\r\n            safeStringAtDatafile(DATAFILE12, alllogValueToSafe, context);\r\n            DebugLog.renewTheLog();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This method clears the DebugLog-Datafile.\r\n     */\r\n    public static void clearDebugLog(Context context) {\r\n        Log.d(TAG, \"clearDebugLog() was called.\");\r\n        safeStringAtDatafile(DATAFILE12, \"\", context);\r\n        DebugLog.renewTheLog();\r\n    }\r\n\r\n    /**\r\n     * This Method returns an Array of Strings (the logValues).\r\n     * The format of the Strings is the following:\r\n     * logValue + \"----\" + new Date().toString()\r\n     *\r\n     * @return A list of Strings. If there are no saved logValues, the return-value is null.\r\n     */\r\n    public static String[] getDebugValues(Context context) {\r\n        Log.d(TAG, \"getDebugValues was called.\");\r\n        return getValuesAsArray(DATAFILE12, context);\r\n    }\r\n\r\n    public static void setIsAlarmRingLogged(boolean value, Context context) {\r\n        safeStringAtDatafile(DATAFILE13, String.valueOf(value), context);\r\n    }\r\n\r\n    public static boolean isAlarmRingLogged(Context context) {\r\n        try {\r\n            return Boolean.valueOf(readDataFile(DATAFILE13, context));\r\n        } catch (Exception e) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public static void setIsAlarmSetLogged(boolean value, Context context) {\r\n        safeStringAtDatafile(DATAFILE14, String.valueOf(value), context);\r\n    }\r\n\r\n    public static boolean isAlarmSetLogged(Context context) {\r\n        try {\r\n            return Boolean.valueOf(readDataFile(DATAFILE14, context));\r\n        } catch (Exception e) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public static void setIsKeyTransmitLogged(boolean value, Context context) {\r\n        safeStringAtDatafile(DATAFILE15, String.valueOf(value), context);\r\n    }\r\n\r\n    public static boolean isKeyTransmitLogged(Context context) {\r\n        try {\r\n            return Boolean.valueOf(readDataFile(DATAFILE15, context));\r\n        } catch (Exception e) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public static void setIsKeySafeLogged(boolean value, Context context) {\r\n        safeStringAtDatafile(DATAFILE16, String.valueOf(value), context);\r\n    }\r\n\r\n    public static boolean isKeySafeLogged(Context context) {\r\n        try {\r\n            return Boolean.valueOf(readDataFile(DATAFILE16, context));\r\n        } catch (Exception e) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Safes the list of indirect contacts.\r\n     *\r\n     * @author Klein\r\n     */\r\n\r\n    public synchronized static void safeListOfIndirectContacts(ArrayList<IndirectContact> indirectContactArrayList) {\r\n        try {\r\n            FileOutputStream fos = BeaconBackgroundService.getAppContext().openFileOutput(DATAFILE21, Context.MODE_PRIVATE);\r\n            ObjectOutputStream oos = new ObjectOutputStream(fos);\r\n            oos.writeObject(indirectContactArrayList);\r\n            oos.close();\r\n            fos.close();\r\n        } catch (IOException ioe) {\r\n            ioe.printStackTrace();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the list of the indirect contacts\r\n     *\r\n     * @author Klein\r\n     */\r\n\r\n    public synchronized static ArrayList<IndirectContact> getListOfIndirectContacts() {\r\n\r\n        ArrayList<IndirectContact> indirectContactArrayList = new ArrayList<>();\r\n        try {\r\n            FileInputStream fis = new FileInputStream(DATAFILE21);\r\n            ObjectInputStream ois = new ObjectInputStream(fis);\r\n\r\n            indirectContactArrayList = (ArrayList) ois.readObject();\r\n            ois.close();\r\n            fis.close();\r\n        } catch (IOException ioe) {\r\n            ioe.printStackTrace();\r\n        } catch (ClassNotFoundException c) {\r\n            System.out.println(\"Class not found\");\r\n            c.printStackTrace();\r\n\r\n        }\r\n\r\n        return indirectContactArrayList;\r\n    }\r\n\r\n    /**\r\n     * Safes the list of direct contacts.\r\n     *\r\n     * @author Klein\r\n     */\r\n\r\n    public synchronized static void safeListOfDirectContacts(ArrayList<DirectContact> directContactArrayList) {\r\n        try {\r\n\r\n            FileOutputStream fos = BeaconBackgroundService.getAppContext().openFileOutput(DATAFILE22, Context.MODE_PRIVATE);\r\n            ObjectOutputStream oos = new ObjectOutputStream(fos);\r\n            oos.writeObject(directContactArrayList);\r\n            oos.close();\r\n            fos.close();\r\n        } catch (IOException ioe) {\r\n            ioe.printStackTrace();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * returns the list of direct contacts.\r\n     *\r\n     * @author Klein\r\n     */\r\n\r\n    public synchronized static ArrayList<DirectContact> getListOfDirectContacts() {\r\n\r\n        ArrayList<DirectContact> directContactArrayList = new ArrayList<>();\r\n        try {\r\n            FileInputStream fis = new FileInputStream(DATAFILE22);\r\n            ObjectInputStream ois = new ObjectInputStream(fis);\r\n\r\n            directContactArrayList = (ArrayList) ois.readObject();\r\n            ois.close();\r\n            fis.close();\r\n        } catch (IOException ioe) {\r\n            ioe.printStackTrace();\r\n        } catch (ClassNotFoundException c) {\r\n            System.out.println(\"Class not found\");\r\n            c.printStackTrace();\r\n\r\n        }\r\n\r\n        return directContactArrayList;\r\n    }\r\n\r\n    /**\r\n     * Safes the date of last reported infection.\r\n     *\r\n     * @param date\r\n     */\r\n    public static void safeDateOfLastReportedInfection(String date, Context context) {\r\n        Log.d(TAG, \"safeDateOfLastReportedInfection() was called with \" + date);\r\n        safeStringAtDatafile(DATAFILE23, date, context);\r\n    }\r\n\r\n    /**\r\n     * Getter for the date of the last reported infection.\r\n     *\r\n     * @return\r\n     */\r\n    public static String getDateOfLastReportedInfection(Context context) {\r\n        Log.d(TAG, \"getDateOfLastReportedInfection() was called.\");\r\n        return readDataFile(DATAFILE23, context);\r\n    }\r\n\r\n    public static void setIsfirstAppStart(boolean value, Context context) {\r\n        safeStringAtDatafile(DATAFILE17, String.valueOf(value), context);\r\n    }\r\n\r\n    public static boolean isFirstAppStart(Context context) {\r\n        try {\r\n            return Boolean.valueOf(readDataFile(DATAFILE17, context));\r\n        } catch (Exception e) {\r\n            return true;\r\n        }\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/de/hhn/frontend/provider/LocalSafer.java	(revision 157afee292ab37f2074e0273eb99aed1ce3ffbe0)
+++ app/src/main/java/de/hhn/frontend/provider/LocalSafer.java	(date 1606746020026)
@@ -463,37 +463,6 @@
         }
     }
 
-    public synchronized static void safeIndirectContacts(String[] indirectContacts, Context context) {
-        if (indirectContacts == null) {
-            safeStringAtDatafile(DATAFILE08, "", context);
-        } else {
-            String value = "-<>-";
-            for (String string: indirectContacts) {
-                value = value + string + "-<>-";
-            }
-            safeStringAtDatafile(DATAFILE08, value, context);
-        }
-    }
-    public synchronized static void safeDirectContacts(String[] directContacts, Context context) {
-        if (directContacts == null) {
-            safeStringAtDatafile(DATAFILE10, "", context);
-        } else {
-            String value = "-<>-";
-            for (String string: directContacts) {
-                value = value + string + "-<>-";
-            }
-            safeStringAtDatafile(DATAFILE10, value, context);
-        }
-    }
-
-    public synchronized static String[] getIndirectContacts(Context context) {
-        return getValuesAsArray(DATAFILE08, context);
-    }
-
-    public synchronized static String[] getdirectContacts(Context context) {
-        return getValuesAsArray(DATAFILE10, context);
-    }
-
     /**
      * Setter for the notificationCount
      *
Index: app/src/androidTest/java/de/monokel/frontend/LocalSaferTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/androidTest/java/de/monokel/frontend/LocalSaferTest.java	(date 1606745926312)
+++ app/src/androidTest/java/de/monokel/frontend/LocalSaferTest.java	(date 1606745926312)
@@ -0,0 +1,74 @@
+package de.monokel.frontend;
+
+import android.content.Context;
+
+import androidx.test.platform.app.InstrumentationRegistry;
+import org.junit.Before;
+import org.junit.Test;
+
+import de.hhn.frontend.provider.LocalSafer;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+
+/**
+ * Test-class for the LocalSafer-Class
+ *
+ * @author Miftari
+ */
+public class LocalSaferTest {
+
+    Context appContext;
+
+    @Before
+    public void setAppContext() {
+        appContext = InstrumentationRegistry.getInstrumentation().getTargetContext();
+    }
+
+    @Test
+    public void settingsTest() {
+        LocalSafer.setIsAlarmRingLogged(false, appContext);
+        LocalSafer.setIsAlarmSetLogged(false, appContext);
+        LocalSafer.setIsKeySafeLogged(false, appContext);
+        LocalSafer.setIsKeyTransmitLogged(false, appContext);
+        LocalSafer.setIsfirstAppStart(false, appContext);
+
+        assertFalse(LocalSafer.isAlarmRingLogged(appContext));
+        assertFalse(LocalSafer.isAlarmSetLogged(appContext));
+        assertFalse(LocalSafer.isKeySafeLogged(appContext));
+        assertFalse(LocalSafer.isKeyTransmitLogged(appContext));
+        assertFalse(LocalSafer.isFirstAppStart(appContext));
+
+        LocalSafer.setIsAlarmRingLogged(true, appContext);
+        LocalSafer.setIsAlarmSetLogged(true, appContext);
+        LocalSafer.setIsKeySafeLogged(true, appContext);
+        LocalSafer.setIsKeyTransmitLogged(true, appContext);
+        LocalSafer.setIsfirstAppStart(true, appContext);
+
+        assertTrue(LocalSafer.isAlarmRingLogged(appContext));
+        assertTrue(LocalSafer.isAlarmSetLogged(appContext));
+        assertTrue(LocalSafer.isKeySafeLogged(appContext));
+        assertTrue(LocalSafer.isKeyTransmitLogged(appContext));
+        assertTrue(LocalSafer.isFirstAppStart(appContext));
+    }
+
+    @Test
+    public void debugLogTest() {
+        LocalSafer.clearDebugLog(appContext);
+        assertNull(LocalSafer.getDebugValues(appContext));
+        LocalSafer.addLogValueToDebugLog("test", appContext);
+        assertTrue(LocalSafer.getDebugValues(appContext)[0].startsWith("test"));
+        LocalSafer.clearDebugLog(appContext);
+        assertNull(LocalSafer.getDebugValues(appContext));
+    }
+
+    @Test
+    public void notificationCountTest() {
+        LocalSafer.safeNotificationCounter(0, appContext);
+        assertEquals(0, LocalSafer.getNotificationCounter(appContext));
+        LocalSafer.safeNotificationCounter(1, appContext);
+        assertEquals(1, LocalSafer.getNotificationCounter(appContext));
+    }
+}
\ No newline at end of file
