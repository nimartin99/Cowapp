Index: app/src/main/java/de/monokel/frontend/provider/Alarm.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package de.monokel.frontend.provider;\r\n\r\n/**\r\n * This class has the method which is called once a day.\r\n *\r\n * @author Miftari\r\n */\r\npublic class Alarm {\r\n\r\n    /**\r\n     * This method is called once a day.\r\n     */\r\n    public static void dailyBusiness() {\r\n        //delete all keys older then 3 weeks.\r\n        LocalKeySafer.addKeyPairToSavedKeyPairs(null);\r\n        LocalNotificationSafer.addNotificationToSavedNotifications(null);\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/de/monokel/frontend/provider/Alarm.java	(revision e980dc172f1b4973813922b0f71e0cb86956fb95)
+++ app/src/main/java/de/monokel/frontend/provider/Alarm.java	(date 1604334939067)
@@ -1,5 +1,10 @@
 package de.monokel.frontend.provider;
 
+import de.monokel.frontend.MainActivity;
+import de.monokel.frontend.risklevel.RiskLevel;
+
+import static de.monokel.frontend.MainActivity.getRiskLevel;
+
 /**
  * This class has the method which is called once a day.
  *
@@ -14,5 +19,14 @@
         //delete all keys older then 3 weeks.
         LocalKeySafer.addKeyPairToSavedKeyPairs(null);
         LocalNotificationSafer.addNotificationToSavedNotifications(null);
+
+        RiskLevel riskLevel(MainActivity.getRiskLevel()) = new RiskLevel();
+        
+
+
+
+
+
+
     }
 }
Index: app/src/main/java/de/monokel/frontend/MainActivity.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package de.monokel.frontend;\r\n\r\nimport androidx.appcompat.app.AppCompatActivity;\r\n\r\nimport android.app.NotificationChannel;\r\nimport android.app.NotificationManager;\r\nimport android.app.PendingIntent;\r\nimport android.content.Context;\r\nimport android.Manifest;\r\nimport android.annotation.TargetApi;\r\nimport android.app.AlarmManager;\r\nimport android.app.AlertDialog;\r\nimport android.content.BroadcastReceiver;\r\nimport android.content.DialogInterface;\r\nimport android.content.Intent;\r\nimport android.content.IntentFilter;\r\nimport android.content.SharedPreferences;\r\nimport android.os.Build;\r\nimport android.content.pm.PackageManager;\r\nimport android.os.Bundle;\r\nimport android.util.Log;\r\nimport android.view.View;\r\nimport android.widget.Button;\r\nimport android.widget.ImageButton;\r\n\r\nimport org.altbeacon.beacon.BeaconManager;\r\n\r\nimport java.util.Calendar;\r\nimport java.util.HashMap;\r\nimport java.util.Objects;\r\n\r\nimport de.monokel.frontend.exceptions.KeyNotRequestedException;\r\nimport de.monokel.frontend.provider.Alarm;\r\nimport de.monokel.frontend.provider.Key;\r\nimport de.monokel.frontend.provider.LocalKeySafer;\r\nimport de.monokel.frontend.provider.NotificationService;\r\nimport de.monokel.frontend.provider.RequestedObject;\r\nimport de.monokel.frontend.provider.RetrofitService;\r\nimport de.monokel.frontend.utils.RetryCallUtil;\r\nimport retrofit2.Call;\r\nimport retrofit2.Callback;\r\nimport retrofit2.Response;\r\nimport retrofit2.Retrofit;\r\nimport retrofit2.converter.gson.GsonConverterFactory;\r\n\r\n/**\r\n * Main screen for CoWApp\r\n *\r\n * @author Tabea leibl\r\n * @author Philipp Alessandrini, Mergim Miftari\r\n * @version 2020-10-28\r\n */\r\npublic class MainActivity extends AppCompatActivity {\r\n\r\n    //TAG for Logging example: Log.d(TAG, \"fine location permission granted\"); -> d for debug\r\n    protected static final String TAG = \"MainActivity\";\r\n\r\n    //For push notification\r\n    public static final String CHANNEL_ID = \"pushNotifications\";\r\n    private NotificationManager notificationManager;\r\n\r\n    private Retrofit retrofit;\r\n    private RetrofitService retrofitService;\r\n    private String BASE_URL = \"http://10.0.2.2:3000\"; // for emulated phone\r\n\r\n    //Expected Permission Values\r\n    private static final int PERMISSION_REQUEST_FINE_LOCATION = 1;\r\n    private static final int PERMISSION_REQUEST_BACKGROUND_LOCATION = 2;\r\n\r\n    //For the once-a-day-alarm-clock for deleting keys that are older than 3 weeks\r\n    private PendingIntent myPendingIntent;\r\n    private AlarmManager alarmManager;\r\n    private BroadcastReceiver myBroadcastReceiver;\r\n    private Calendar firingCal;\r\n\r\n    String prefDataProtection = \"ausstehend\";\r\n\r\n    @Override\r\n    protected void onCreate(Bundle savedInstanceState) {\r\n        super.onCreate(savedInstanceState);\r\n        setContentView(R.layout.activity_main);\r\n\r\n        //Check bluetooth and location turned on\r\n        verifyBluetooth();\r\n        //Request needed permissions\r\n        requestPermissions();\r\n\r\n        // init retrofit\r\n        retrofit = new Retrofit.Builder()\r\n                .baseUrl(BASE_URL)\r\n                .addConverterFactory(GsonConverterFactory.create())\r\n                .build();\r\n        retrofitService = retrofit.create(RetrofitService.class);\r\n\r\n        //Create channel for push up notifications\r\n        createNotificationChannel();\r\n\r\n        //If the app is opened for the first time the user has to accept the data protection regulations\r\n        if (firstAppStart()) {\r\n            Intent nextActivity = new Intent(MainActivity.this, DataProtectionActivity.class);\r\n            startActivity(nextActivity);\r\n        } else {\r\n            //Info button listener\r\n            Button infoButton = (Button) findViewById(R.id.InfoButton);\r\n\r\n            infoButton.setOnClickListener(new View.OnClickListener() {\r\n                @Override\r\n                public void onClick(View v) {\r\n                    //Go to info screen\r\n                    Intent nextActivity = new Intent(MainActivity.this, InfoActivity.class);\r\n                    startActivity(nextActivity);\r\n                }\r\n            });\r\n\r\n            //Settings button listener\r\n            ImageButton settingsButton = (ImageButton) findViewById(R.id.EinstellungenButton);\r\n\r\n            settingsButton.setOnClickListener(new View.OnClickListener() {\r\n                @Override\r\n                public void onClick(View v) {\r\n                    //Go to settings screen\r\n                    Intent nextActivity = new Intent(MainActivity.this, SettingsActivity.class);\r\n                    startActivity(nextActivity);\r\n                }\r\n            });\r\n\r\n            //LOG button listener\r\n            Button logButton = (Button) findViewById(R.id.LOGButton);\r\n\r\n            logButton.setOnClickListener(new View.OnClickListener() {\r\n                @Override\r\n                public void onClick(View v) {\r\n                    //Go to LOG screen\r\n                    Intent nextActivity = new Intent(MainActivity.this, LogActivity.class);\r\n                    startActivity(nextActivity);\r\n                }\r\n            });\r\n\r\n            //Test menu button listener\r\n            Button testMenuButton = (Button) findViewById(R.id.TestMenuButton);\r\n\r\n            testMenuButton.setOnClickListener(new View.OnClickListener() {\r\n                @Override\r\n                public void onClick(View v) {\r\n                    //Go to test menu screen\r\n                    Intent nextActivity = new Intent(MainActivity.this, TestMenuActivity.class);\r\n                    startActivity(nextActivity);\r\n                }\r\n            });\r\n\r\n            //Report infection button listener\r\n            Button reportInfectionButton = (Button) findViewById(R.id.InfektionMeldenButton);\r\n\r\n            reportInfectionButton.setOnClickListener(new View.OnClickListener() {\r\n                @Override\r\n                public void onClick(View v) {\r\n                    //Go to screen to report infection\r\n                    Intent nextActivity = new Intent(MainActivity.this, ReportInfectionActivity.class);\r\n                    startActivity(nextActivity);\r\n                }\r\n            });\r\n\r\n            //suspicion button listener\r\n            Button suspicionButton = (Button) findViewById(R.id.VerdachtButton);\r\n\r\n            suspicionButton.setOnClickListener(new View.OnClickListener() {\r\n                @Override\r\n                public void onClick(View v) {\r\n                    //Go to screen to inform what to do with infection suspicion\r\n                    Intent nextActivity = new Intent(MainActivity.this, SuspicionActivity.class);\r\n                    startActivity(nextActivity);\r\n                }\r\n            });\r\n        }\r\n\r\n        //Register AlarmManager Broadcast receive. (For the once-a-day-alarm-clock for deleting keys older then 3 weeks.\r\n        firingCal= Calendar.getInstance();\r\n        firingCal.set(Calendar.HOUR, 8); // alarm hour\r\n        firingCal.set(Calendar.MINUTE, 0); // alarm minute\r\n        firingCal.set(Calendar.SECOND, 0); // and alarm second\r\n        long intendedTime = firingCal.getTimeInMillis();\r\n\r\n        registerMyAlarmBroadcast();\r\n        alarmManager.setRepeating( AlarmManager.RTC_WAKEUP, intendedTime , AlarmManager.INTERVAL_DAY , myPendingIntent );\r\n    }\r\n\r\n    /**\r\n     * This method supports the once-a-day-alarm-clock for deleting keys older then 3 weeks.\r\n     */\r\n    private void registerMyAlarmBroadcast()\r\n    {\r\n        //This is the call back function(BroadcastReceiver) which will be call when your\r\n        //alarm time will reached.\r\n        myBroadcastReceiver = new BroadcastReceiver() {\r\n            @Override\r\n            public void onReceive(Context context, Intent intent) {\r\n                Alarm.dailyBusiness();\r\n            }\r\n        };\r\n\r\n        registerReceiver(myBroadcastReceiver, new IntentFilter(\"com.alarm.example\") );\r\n        myPendingIntent = PendingIntent.getBroadcast( this, 0, new Intent(\"com.alarm.example\"),0 );\r\n        alarmManager = (AlarmManager)(this.getSystemService( Context.ALARM_SERVICE ));\r\n    }\r\n\r\n    /**\r\n     * At first start of the app the user has to accept the data protection regulations before he can\r\n     * use the app\r\n     */\r\n    public boolean firstAppStart() {\r\n        SharedPreferences preferences = getSharedPreferences(prefDataProtection, MODE_PRIVATE);\r\n        if (preferences.getBoolean(prefDataProtection, true)) {\r\n            SharedPreferences.Editor editor = preferences.edit();\r\n            editor.putBoolean(prefDataProtection, false);\r\n            editor.commit();\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Request a new key from the server.\r\n     */\r\n    public void requestKey() {\r\n        Call<RequestedObject> call = retrofitService.requestKey();\r\n        RetryCallUtil.enqueueWithRetry(call, new Callback<RequestedObject>() {\r\n            @Override\r\n            public void onResponse(Call<RequestedObject> call, Response<RequestedObject> response) {\r\n                if (response.code() == 200) {\r\n                    RequestedObject requestedKey = response.body();\r\n                    // set the key\r\n                    Key.setKey(requestedKey.getKey());\r\n                    // log key\r\n                    Log.i(TAG, \"Key: \" + Key.getKey());\r\n                } else if (response.code() == 404) {\r\n                    Log.i(TAG, \"Key doesn't exist\");\r\n                }\r\n            }\r\n\r\n            @Override\r\n            public void onFailure(Call<RequestedObject> call, Throwable t) {\r\n                Log.w(TAG, Objects.requireNonNull(t.getMessage()));\r\n                noConnectionNotification();\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Report an infection by sending the current key to the server.\r\n     *\r\n     * @throws KeyNotRequestedException if this method is called before a key is requested\r\n     */\r\n    public void reportInfection() throws KeyNotRequestedException {\r\n        if (Key.getKey() == null) {\r\n            throw new KeyNotRequestedException(\"A key needs to be requested first\");\r\n        } else {\r\n            HashMap<String, String> keyMap = new HashMap<>();\r\n            keyMap.put(\"date\", Calendar.getInstance().getTime().toString());\r\n            keyMap.put(\"key\", Key.getKey());\r\n\r\n            Call<Void> call = retrofitService.reportInfection(keyMap);\r\n            RetryCallUtil.enqueueWithRetry(call, new Callback<Void>() {\r\n                @Override\r\n                public void onResponse(Call<Void> call, Response<Void> response) {\r\n                    if (response.code() == 200) {\r\n                        Log.i(TAG, \"Infection reported successfully\");\r\n                    } else if (response.code() == 400) {\r\n                        Log.i(TAG, \"Infection already reported\");\r\n                    }\r\n                }\r\n\r\n                @Override\r\n                public void onFailure(Call<Void> call, Throwable t) {\r\n                    Log.w(TAG, Objects.requireNonNull(t.getMessage()));\r\n                    noConnectionNotification();\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    // standard notification if there is no connection to the server\r\n    private void noConnectionNotification() {\r\n        Intent retryRequestPushNotification = new Intent(MainActivity.this,\r\n                NotificationService.class);\r\n        retryRequestPushNotification.putExtra(\"TITLE\", \"Es konnte keine Verbindung zum Server hergestellt werden\");\r\n        retryRequestPushNotification.putExtra(\"TEXT\", \"Versuche Verbindungsaufbau in 5 Minuten erneut...\");\r\n        startService(retryRequestPushNotification);\r\n    }\r\n\r\n    /**\r\n     * Request all needed permissions based on SDK Version\r\n     * (Permission already requested in Manifest -> double check)\r\n     */\r\n    private void requestPermissions() {\r\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {\r\n            if (this.checkSelfPermission(Manifest.permission.ACCESS_FINE_LOCATION)\r\n                    == PackageManager.PERMISSION_GRANTED) {\r\n                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {\r\n                    if (this.checkSelfPermission(Manifest.permission.ACCESS_BACKGROUND_LOCATION)\r\n                            != PackageManager.PERMISSION_GRANTED) {\r\n                        if (!this.shouldShowRequestPermissionRationale(Manifest.permission.ACCESS_BACKGROUND_LOCATION)) {\r\n                            final AlertDialog.Builder builder = new AlertDialog.Builder(this);\r\n                            builder.setTitle(\"This app needs background location access\");\r\n                            builder.setMessage(\"Please grant location access so this app can detect beacons in the background.\");\r\n                            builder.setPositiveButton(android.R.string.ok, null);\r\n                            builder.setOnDismissListener(new DialogInterface.OnDismissListener() {\r\n\r\n                                @TargetApi(23)\r\n                                @Override\r\n                                public void onDismiss(DialogInterface dialog) {\r\n                                    requestPermissions(new String[]{Manifest.permission.ACCESS_BACKGROUND_LOCATION},\r\n                                            PERMISSION_REQUEST_BACKGROUND_LOCATION);\r\n                                }\r\n\r\n                            });\r\n                            builder.show();\r\n                        } else {\r\n                            final AlertDialog.Builder builder = new AlertDialog.Builder(this);\r\n                            builder.setTitle(\"Functionality limited\");\r\n                            builder.setMessage(\"Since background location access has not been granted, this app will not be able to discover beacons in the background.  Please go to Settings -> Applications -> Permissions and grant background location access to this app.\");\r\n                            builder.setPositiveButton(android.R.string.ok, null);\r\n                            builder.setOnDismissListener(new DialogInterface.OnDismissListener() {\r\n\r\n                                @Override\r\n                                public void onDismiss(DialogInterface dialog) {\r\n                                }\r\n\r\n                            });\r\n                            builder.show();\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                if (!this.shouldShowRequestPermissionRationale(Manifest.permission.ACCESS_FINE_LOCATION)) {\r\n                    requestPermissions(new String[]{Manifest.permission.ACCESS_FINE_LOCATION,\r\n                                    Manifest.permission.ACCESS_BACKGROUND_LOCATION},\r\n                            PERMISSION_REQUEST_FINE_LOCATION);\r\n                } else {\r\n                    final AlertDialog.Builder builder = new AlertDialog.Builder(this);\r\n                    builder.setTitle(\"Functionality limited\");\r\n                    builder.setMessage(\"Since location access has not been granted, this app will not be able to discover beacons.  Please go to Settings -> Applications -> Permissions and grant location access to this app.\");\r\n                    builder.setPositiveButton(android.R.string.ok, null);\r\n                    builder.setOnDismissListener(new DialogInterface.OnDismissListener() {\r\n\r\n                        @Override\r\n                        public void onDismiss(DialogInterface dialog) {\r\n                        }\r\n\r\n                    });\r\n                    builder.show();\r\n                }\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Verify if Bluetooth is turned on and if BLE is supported\r\n     */\r\n    private void verifyBluetooth() {\r\n        try {\r\n            if (!BeaconManager.getInstanceForApplication(this).checkAvailability()) {\r\n                final AlertDialog.Builder builder = new AlertDialog.Builder(this);\r\n                builder.setTitle(\"Bluetooth not enabled\");\r\n                builder.setMessage(\"Please enable bluetooth in settings and restart this application.\");\r\n                builder.setPositiveButton(android.R.string.ok, null);\r\n                builder.setOnDismissListener(new DialogInterface.OnDismissListener() {\r\n                    @Override\r\n                    public void onDismiss(DialogInterface dialog) {\r\n                        //finish();\r\n                        //System.exit(0);\r\n                    }\r\n                });\r\n                builder.show();\r\n            }\r\n        } catch (RuntimeException e) {\r\n            final AlertDialog.Builder builder = new AlertDialog.Builder(this);\r\n            builder.setTitle(\"Bluetooth LE not available\");\r\n            builder.setMessage(\"Sorry, this device does not support Bluetooth LE.\");\r\n            builder.setPositiveButton(android.R.string.ok, null);\r\n            builder.setOnDismissListener(new DialogInterface.OnDismissListener() {\r\n\r\n                @Override\r\n                public void onDismiss(DialogInterface dialog) {\r\n                    //finish();\r\n                    //System.exit(0);\r\n                }\r\n\r\n            });\r\n            builder.show();\r\n\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Permission dialog result catch to follow further steps if not granted\r\n     * @param requestCode\r\n     * @param permissions\r\n     * @param grantResults\r\n     */\r\n    @Override\r\n    public void onRequestPermissionsResult(int requestCode,\r\n                                           String permissions[], int[] grantResults) {\r\n        switch (requestCode) {\r\n            case PERMISSION_REQUEST_FINE_LOCATION: {\r\n                if (grantResults[0] == PackageManager.PERMISSION_GRANTED) {\r\n                    Log.d(TAG, \"fine location permission granted\");\r\n                } else {\r\n                    final AlertDialog.Builder builder = new AlertDialog.Builder(this);\r\n                    builder.setTitle(\"Functionality limited\");\r\n                    builder.setMessage(\"Since location access has not been granted, this app will not be able to discover beacons.\");\r\n                    builder.setPositiveButton(android.R.string.ok, null);\r\n                    builder.setOnDismissListener(new DialogInterface.OnDismissListener() {\r\n\r\n                        @Override\r\n                        public void onDismiss(DialogInterface dialog) {\r\n                        }\r\n\r\n                    });\r\n                    builder.show();\r\n                }\r\n                return;\r\n            }\r\n            case PERMISSION_REQUEST_BACKGROUND_LOCATION: {\r\n                if (grantResults[0] == PackageManager.PERMISSION_GRANTED) {\r\n                    Log.d(TAG, \"background location permission granted\");\r\n                } else {\r\n                    final AlertDialog.Builder builder = new AlertDialog.Builder(this);\r\n                    builder.setTitle(\"Functionality limited\");\r\n                    builder.setMessage(\"Since background location access has not been granted, this app will not be able to discover beacons when in the background.\");\r\n                    builder.setPositiveButton(android.R.string.ok, null);\r\n                    builder.setOnDismissListener(new DialogInterface.OnDismissListener() {\r\n\r\n                        @Override\r\n                        public void onDismiss(DialogInterface dialog) {\r\n                        }\r\n\r\n                    });\r\n                    builder.show();\r\n                }\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    //create channel for the notification to be delivered as heads-up notification\r\n    private void createNotificationChannel() {\r\n        // Create the NotificationChannel (only on API 26+ because\r\n        // the NotificationChannel class is new and not in the support library)\r\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\r\n            CharSequence name = getString(R.string.channel_name);\r\n            String description = getString(R.string.channel_description);\r\n            int importance = NotificationManager.IMPORTANCE_HIGH; //high priority for heads-up notifications for android 8.0 and higher\r\n            NotificationChannel channel = new NotificationChannel(CHANNEL_ID, name, importance);\r\n            channel.setDescription(description);\r\n            // Register the channel with the system; you can't change the importance\r\n            // or other notification behaviors after this\r\n            notificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);\r\n            notificationManager.createNotificationChannel(channel);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Safes the own key in the shared preferences.\r\n     * @param key the own key as String\r\n     */\r\n    public void safeOwnKey(String key) {\r\n        SharedPreferences prefs = getPreferences(Context.MODE_PRIVATE);\r\n        SharedPreferences.Editor meinEditor = prefs.edit();\r\n        meinEditor.putString(\"ownKey\", key);\r\n        meinEditor.apply();\r\n    }\r\n\r\n    /**\r\n     * Getter for the own key out of the shared preferences\r\n     * @return the own key as String\r\n     */\r\n    public String getOwnKey() {\r\n        SharedPreferences prefs = getPreferences(Context.MODE_PRIVATE);\r\n        return prefs.getString(\"ownKey\", null);\r\n    }\r\n\r\n    /**\r\n     * Safes the risk Level in the shared preferences.\r\n     * @param riskLevel risk level as int\r\n     */\r\n    public void safeRiskLevel(int riskLevel) {\r\n        SharedPreferences prefs = getPreferences(Context.MODE_PRIVATE);\r\n        SharedPreferences.Editor meinEditor = prefs.edit();\r\n        meinEditor.putInt(\"riskLevel\", riskLevel);\r\n        meinEditor.apply();\r\n    }\r\n\r\n    /**\r\n     * Getter for the risk level out oh the shared prefernces.\r\n     * @return risk level as int.\r\n     */\r\n    public int getRiskLevel() {\r\n        SharedPreferences prefs = getPreferences(Context.MODE_PRIVATE);\r\n        return prefs.getInt(\"riskLevel\", 0);\r\n    }\r\n\r\n    /**\r\n     * Safes the daysSinceLastContact in the shared preferences.\r\n     * @param daysSinceLastContact days Since laste contact as int.\r\n     */\r\n    public void safeDaysSinceLastContact(int daysSinceLastContact) {\r\n        SharedPreferences prefs = getPreferences(Context.MODE_PRIVATE);\r\n        SharedPreferences.Editor meinEditor = prefs.edit();\r\n        meinEditor.putInt(\"daysSinceLastContact\", daysSinceLastContact);\r\n        meinEditor.apply();\r\n    }\r\n\r\n    /**\r\n     * Getter for the daysSinceLastContact out of the shared preferences.\r\n     * @return the days since last Contact as int.\r\n     */\r\n    public int getDaysSinceLastContact() {\r\n        SharedPreferences prefs = getPreferences(Context.MODE_PRIVATE);\r\n        return prefs.getInt(\"daysSinceLastContact\", 0);\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/de/monokel/frontend/MainActivity.java	(revision e980dc172f1b4973813922b0f71e0cb86956fb95)
+++ app/src/main/java/de/monokel/frontend/MainActivity.java	(date 1604334939098)
@@ -494,10 +494,10 @@
     }
 
     /**
-     * Getter for the risk level out oh the shared prefernces.
+     * Getter for the risk level out of the shared preferences.
      * @return risk level as int.
      */
-    public int getRiskLevel() {
+    public static int getRiskLevel() {
         SharedPreferences prefs = getPreferences(Context.MODE_PRIVATE);
         return prefs.getInt("riskLevel", 0);
     }
Index: settings.gradle
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>include ':app'\r\nrootProject.name = \"frontend\"
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- settings.gradle	(revision e980dc172f1b4973813922b0f71e0cb86956fb95)
+++ settings.gradle	(date 1603991147852)
@@ -1,2 +1,3 @@
+include ':jonasLib'
 include ':app'
 rootProject.name = "frontend"
\ No newline at end of file
Index: .idea/gradle.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"GradleMigrationSettings\" migrationVersion=\"1\" />\r\n  <component name=\"GradleSettings\">\r\n    <option name=\"linkedExternalProjectsSettings\">\r\n      <GradleProjectSettings>\r\n        <option name=\"testRunner\" value=\"PLATFORM\" />\r\n        <option name=\"distributionType\" value=\"DEFAULT_WRAPPED\" />\r\n        <option name=\"externalProjectPath\" value=\"$PROJECT_DIR$\" />\r\n        <option name=\"gradleHome\" value=\"$PROJECT_DIR$/../../../../Program Files/Gradle/gradle-6.3\" />\r\n        <option name=\"gradleJvm\" value=\"1.8\" />\r\n        <option name=\"modules\">\r\n          <set>\r\n            <option value=\"$PROJECT_DIR$\" />\r\n            <option value=\"$PROJECT_DIR$/app\" />\r\n          </set>\r\n        </option>\r\n        <option name=\"resolveModulePerSourceSet\" value=\"false\" />\r\n        <option name=\"useQualifiedModuleNames\" value=\"true\" />\r\n      </GradleProjectSettings>\r\n    </option>\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/gradle.xml	(revision e980dc172f1b4973813922b0f71e0cb86956fb95)
+++ .idea/gradle.xml	(date 1603991147857)
@@ -13,6 +13,7 @@
           <set>
             <option value="$PROJECT_DIR$" />
             <option value="$PROJECT_DIR$/app" />
+            <option value="$PROJECT_DIR$/jonasLib" />
           </set>
         </option>
         <option name="resolveModulePerSourceSet" value="false" />
Index: app/src/main/java/de/monokel/frontend/risklevel/AmountOfContactsEnum.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/de/monokel/frontend/risklevel/AmountOfContactsEnum.java	(date 1604334939080)
+++ app/src/main/java/de/monokel/frontend/risklevel/AmountOfContactsEnum.java	(date 1604334939080)
@@ -0,0 +1,11 @@
+package de.monokel.frontend.risklevel;
+
+/**
+ * Einfaches Enum zur Klassifizierung wie oft etwas stattgefunden hat:
+ * <p>
+ * FEW: 1 bis wenige Fälle
+ * SOME: wenige bis einige Fälle
+ * MANY: einige bis viele Fälle
+ */
+
+public enum AmountOfContactsEnum {FEW, SOME, MANY}
Index: app/src/main/java/de/monokel/frontend/risklevel/TypeOfExposureEnum.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/de/monokel/frontend/risklevel/TypeOfExposureEnum.java	(date 1604334939113)
+++ app/src/main/java/de/monokel/frontend/risklevel/TypeOfExposureEnum.java	(date 1604334939113)
@@ -0,0 +1,13 @@
+package de.monokel.frontend.risklevel;
+
+/**
+ * Enum zur Klassifizierung der Art wie eine Übertragung stattgefunden haben könnte.
+ * Direct contact stellt einen Kontakt mit einer als infiziert gemeldeten Person da.
+ * Indirect Contact stellt einen Kontakt mit einer nicht als infiziert gemeldeten Person da. *
+ * Long und Short Exposure stellen dar ob es sich um lange oder kurze, bzw. entsprechend viele oder wenige Schlüssel ausgetauscht wurden.
+ *
+ * @author jonas
+ * 26.10.2020
+ */
+
+public enum TypeOfExposureEnum {LONG_EXPOSURE_DIRECT_CONTACT, SHORT_EXPOSURE_DIRECT_CONTACT, LONG_EXPOSURE_INDIRECT_CONTACT, SHORT_EXPOSURE_INDIRECT_CONTACT, NO_CONTACT}
Index: app/src/main/java/de/monokel/frontend/risklevel/RiskLevel.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/de/monokel/frontend/risklevel/RiskLevel.java	(date 1604334939121)
+++ app/src/main/java/de/monokel/frontend/risklevel/RiskLevel.java	(date 1604334939121)
@@ -0,0 +1,169 @@
+package de.monokel.frontend.risklevel;
+
+
+import java.util.Collections;
+import java.util.SortedSet;
+import java.util.TreeSet;
+
+/**
+ * Klasse mit allen Operationen welche das Risikolevel betreffen.
+ * Das Risikolevel ist ein Wert zwischen 0 und 100.
+ * Er soll immer jeden Tag aktualisiert werden, oder wenn eine Infektionsmeldung durchgeführt wurde
+ *
+ * @author jonas
+ * @date 26.10.2020
+ */
+
+
+public class RiskLevel {
+
+    private int riskLevel;
+    private int daysSinceLastUpdate;
+    SortedSet s = Collections.synchronizedSortedSet(new TreeSet<Integer>());
+
+
+    public void RiskLevel(int riskLevel) {
+        if (riskLevel < 0 || riskLevel > 100) {
+            throw new IllegalArgumentException();
+        } else {
+            this.riskLevel = riskLevel;
+        }
+    }
+
+    public int returnRiskLevel() {
+        return riskLevel;
+    }
+
+    public int getDaysSinceLastUpdate() {
+        return daysSinceLastUpdate;
+    }
+
+    /**
+     * Methode zur Aktualisierung des Risikolevels.
+     *
+     * @param newRiskLevel  ist das neue Risikolevel, sollte übergeben werden durch die Methode calculateRiskLevel.
+     * @param isDailyUpdate (true/1:) Gibt an ob es sich um die tägliche Aktualisierung handelt, oder um den anderen Fall,(false/0:) dass es sich um eine Aktualisierung aufgrund einer Infektionsmeldung handelt.
+     */
+    public void updateRiskLevel(int newRiskLevel, boolean isDailyUpdate) {
+        if (this.riskLevel < 0 || this.riskLevel > 100) {
+            throw new IllegalArgumentException("Illegal Risk Level");
+        } else if (this.riskLevel > riskLevel || isDailyUpdate) {
+            daysSinceLastUpdate = daysSinceLastUpdate + 1;
+
+        } else if (this.riskLevel > riskLevel || !isDailyUpdate) {
+            daysSinceLastUpdate = daysSinceLastUpdate;
+
+
+        } else if (this.riskLevel < riskLevel || isDailyUpdate) {
+            setRiskLevel(newRiskLevel);
+            resetDaysSinceLastContact();
+        } else if (this.riskLevel < riskLevel || !isDailyUpdate) {
+            setRiskLevel(newRiskLevel);
+            resetDaysSinceLastContact();
+        }
+    }
+
+    /**
+     * gleiche Methode wie die daurauffolgende, nur ohne den 2. Parameter, da dieser hier nicht berücksichtig werden muss.
+     *
+     * @param action Aktion welche beim berechnen des Risikolevels berücktsichtigt werden soll, hier wird jedoch nur ein NO_CONTACT berücktsicht, für alle anderen Fälle wird die nächste Methode verwendet.
+     */
+
+    public void calculateRiskLevel(TypeOfExposureEnum action) {
+        if (action == TypeOfExposureEnum.NO_CONTACT) {
+            this.riskLevel = 0;
+            checkDaysSinceLastContact();
+        }
+    }
+
+    /**
+     * Methode zum berechnen des Risikolevels anhand der übergebenen Aktion
+     *
+     * @param action Art der Aktion welche eine Infektion zur Folge haben könnte
+     * @param amount Anzahl wie oft die zuvor genannte Aktion stattgefunden, z.B.: es wurden 1-wenige Schlüssel ausgetauscht, es wurden wenige - einige Schlüssel ausgetauscht oder eben einige bis viele Schlüssel ausgetauscht.
+     * @return berechneter Wert des Risikolevels
+     */
+
+
+    public int calculateRiskLevel(TypeOfExposureEnum action, AmountOfContactsEnum amount) {
+
+        int localRiskLevel = 0;
+
+        if (action == TypeOfExposureEnum.SHORT_EXPOSURE_INDIRECT_CONTACT || amount == AmountOfContactsEnum.FEW) {
+            localRiskLevel = 20;
+
+        } else if (action == TypeOfExposureEnum.SHORT_EXPOSURE_INDIRECT_CONTACT || amount == AmountOfContactsEnum.SOME) {
+            localRiskLevel = 30;
+        } else if (action == TypeOfExposureEnum.SHORT_EXPOSURE_INDIRECT_CONTACT || amount == AmountOfContactsEnum.MANY) {
+            localRiskLevel = 35;
+
+
+        } else if (action == TypeOfExposureEnum.LONG_EXPOSURE_INDIRECT_CONTACT || amount == AmountOfContactsEnum.FEW) {
+            localRiskLevel = 40;
+        } else if (action == TypeOfExposureEnum.LONG_EXPOSURE_INDIRECT_CONTACT || amount == AmountOfContactsEnum.SOME) {
+            localRiskLevel = 50;
+        } else if (action == TypeOfExposureEnum.LONG_EXPOSURE_INDIRECT_CONTACT || amount == AmountOfContactsEnum.SOME) {
+            localRiskLevel = 60;
+
+
+        } else if (action == TypeOfExposureEnum.SHORT_EXPOSURE_DIRECT_CONTACT || amount == AmountOfContactsEnum.FEW) {
+            localRiskLevel = 90;
+        } else if (action == TypeOfExposureEnum.SHORT_EXPOSURE_DIRECT_CONTACT || amount == AmountOfContactsEnum.SOME) {
+            localRiskLevel = 95;
+        } else if (action == TypeOfExposureEnum.SHORT_EXPOSURE_DIRECT_CONTACT || amount == AmountOfContactsEnum.MANY) {
+            localRiskLevel = 97;
+
+
+        } else if (action == TypeOfExposureEnum.LONG_EXPOSURE_DIRECT_CONTACT || amount == AmountOfContactsEnum.FEW) {
+            localRiskLevel = 96;
+        } else if (action == TypeOfExposureEnum.LONG_EXPOSURE_DIRECT_CONTACT || amount == AmountOfContactsEnum.SOME) {
+            localRiskLevel = 98;
+        } else if (action == TypeOfExposureEnum.LONG_EXPOSURE_DIRECT_CONTACT || amount == AmountOfContactsEnum.MANY) {
+            localRiskLevel = 100;
+        }
+
+        return localRiskLevel;
+
+    }
+
+    private void setRiskLevel(int newRiskLevel) {
+        this.riskLevel = newRiskLevel;
+    }
+
+    private void resetDaysSinceLastContact() {
+        daysSinceLastUpdate = 0;
+    }
+
+
+    public void checkDaysSinceLastContact() {
+        if (daysSinceLastUpdate > 14) {
+            this.riskLevel = 0;
+            daysSinceLastUpdate = 0;
+        }
+    }
+
+    public void resetRiskLevel() {
+        this.riskLevel = 0;
+
+    }
+    /*
+    public void checkRiskLevel(){
+
+        if(riskLevel < 33 || riskLevel >= 0){
+            this.riskLevelString = "Low Risk Level!";
+            }
+        if(riskLevel < 67 || riskLevel > 33){
+            this.riskLevelString = "Medium Risk Level!";
+             }
+        if(riskLevel < 101 || riskLevel > 66){
+            this.riskLevelString = "High Risk Level!";
+        }
+            }
+
+     */
+
+
+}
+
+
+
Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"ProjectRootManager\" version=\"2\" languageLevel=\"JDK_1_8\" default=\"true\" project-jdk-name=\"1.8\" project-jdk-type=\"JavaSDK\">\r\n    <output url=\"file://$PROJECT_DIR$/build/classes\" />\r\n  </component>\r\n  <component name=\"ProjectType\">\r\n    <option name=\"id\" value=\"Android\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/misc.xml	(revision e980dc172f1b4973813922b0f71e0cb86956fb95)
+++ .idea/misc.xml	(date 1603991148123)
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
-  <component name="ProjectRootManager" version="2" languageLevel="JDK_1_8" default="true" project-jdk-name="1.8" project-jdk-type="JavaSDK">
+  <component name="ProjectRootManager" version="2" languageLevel="JDK_1_8" project-jdk-name="1.8" project-jdk-type="JavaSDK">
     <output url="file://$PROJECT_DIR$/build/classes" />
   </component>
   <component name="ProjectType">
Index: .idea/compiler.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"CompilerConfiguration\">\r\n    <bytecodeTargetLevel target=\"1.8\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/compiler.xml	(revision e980dc172f1b4973813922b0f71e0cb86956fb95)
+++ .idea/compiler.xml	(date 1603991182432)
@@ -1,6 +1,8 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
   <component name="CompilerConfiguration">
-    <bytecodeTargetLevel target="1.8" />
+    <bytecodeTargetLevel target="1.7">
+      <module name="frontend.app" target="1.8" />
+    </bytecodeTargetLevel>
   </component>
 </project>
\ No newline at end of file
Index: app/src/main/java/de/monokel/frontend/risklevel/Main.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/de/monokel/frontend/risklevel/Main.java	(date 1604334939053)
+++ app/src/main/java/de/monokel/frontend/risklevel/Main.java	(date 1604334939053)
@@ -0,0 +1,37 @@
+package de.monokel.frontend.risklevel;
+
+import java.util.Collections;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.SortedSet;
+import java.util.TreeSet;
+
+/**
+ * Main Klasse um die Funktion von Risklevel zu testen
+ *
+ * @author Jonas
+ * 29.10.2020
+ */
+public class Main {
+
+    private List list = new LinkedList<Integer>();
+
+    public void addToList(int i) {
+        if (list.size() == 14) {
+            list.remove(14);
+            list.add(3);
+
+        } else if (list.size() < 14) {
+            list.add(4);
+
+        }
+    }
+
+    public static void main(String[] args) {
+
+
+    }
+
+
+}
+
